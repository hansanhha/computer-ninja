#### 인덱스
- [메서드 이름 기반 쿼리](#메서드-이름-기반-쿼리)
- [`@Query`, JPQL](#query-jpql)
- [`@Modifying`](#modifying)
- [페이징](#페이징)
- [정렬](#정렬)
- [커스텀 리포지토리](#커스텀-리포지토리)
- [페이지네이션과 `@OneToMany` 성능저하 이슈](#페이지네이션과-onetomany-성능저하-이슈)
- [삽입/업데이트/삭제 배치 처리](#삽입업데이트삭제-배치-처리)


## 메서드 이름 기반 쿼리

```java
public interface UserRepository extends CrudRepository<User, Long> {
    List<User> findByEmail(String email); 
}
```

스프링 데이터 JPA는 애플리케이션 로딩 시점에 `Repository` 인터페이스를 확장한 사용자 정의 인터페이스에 대한 프록시 구현체를 만든다

프록시는 기본 CRUD 연산을 수행하기 위해 `SimpleJpaRepository`를 이용한다 

커스텀 메서드의 경우 메서드 이름을 `PartTree`에게 구문 분석을 맡기고 엔티티의 메타데이터를 기반으로 JPQL을 생성한 뒤 쿼리에 필요한 값을 매핑한다

이후 SQL로 변환하고 엔티티 매니저에게 위임하여 쿼리를 실행하고 결과를 반환 타입에 맞게 전달한다

**`UserRepository` 인터페이스 -> 프록시 -> `PartTree` -> JPQL -> SQL -> 엔티티 매니저 -> 데이터베이스**

유의사항
- 스프링 컨텍스트 초기화 시점에 리포지토리 스캔, PartTree 파싱, JPQL 쿼리 생성 과정이 이뤄진다
- 메서드 호출 시 이미 캐싱된 JPQL을 가져오고 파라미터만 바인딩해서 실행한다 (PreparedStatement 바인딩)
- `@Query`와 메서드 이름 기반 쿼리는 혼합해서 사용할 수 있다

아래와 같이 메서드 파라미터로 `Pageble`을 받지만 `@Query` 문자열 내부에서 사용되지 않아도 스프링 데이터가 내부적으로 페이징 처리를 해준다

단 `@Query` JPQL에 이미 `order by`가 있으면 `Pageable`의 `Sort`는 무시된다

```java
@Query("SELECT u FROM User u WHERE u.createdAt > '2025-09-26'")
Page<User> findAllByUserCreatedAt(Pageable pageable);
```

### 메서드 이름 규칙

`By` 앞: 연산 키워드(조회, 삭제 등)

`By` 뒤: 쿼리할 필드 + 조건 (조건은 And, Or로 추가할 수 있다)

접두사와 By 사이는 쿼리 파싱에 영향을 주지 않기 때문에 부가적인 정보를 명시할 수 있다

조회: `find...By`, `read...By`, `get...By`

개수: `count...By`

존재 여부: `exists...By`

삭제: `delete...By`, `remove...By`

Stream 반환: `stream...By`

### 조건 키워드

단순 비교: Is, Equals - `findByEmail`, `findByEmailIs`

부정: Not - `findByStatusNot`

Null 체크: IsNull, IsNotNull - `findByMoneyIsNull`

문자열: Like, NotLike, StartingWith, EndingWith, Containing

범위: Between, LessThan, LessThanEqual, GreaterThan, GreaterThanEqual

포함 여부: In, NotIn

Boolean 필드: True, False

### 연결 키워드

And, Or

```java
// firstname과 lastName 모두 일치하는 엔티티 조회
findByFirstNameAndLastName(String firstname, String lastName);

// age보다 작거나 status와 일치하는 엔티티 조회
findByAgeLessThanOrStatus(int age, String status);
```

### 정렬 키워드

`...By...OrderBy...Asc/Desc`

```java
// status인 엔티티를 CreatedAt 필드를 기준으로 내림차순 정렬하여 조회
findByStatusOrderByCreatedAtDesc(String status);

// Sort 파라미터 사용
findByStatus(String status, Sort sort);
```

### 페이징

`Pageable` 파라미터와 함께 `Page<T>`, `Slice<T>`, `List<T>` 리턴 타입 사용

```java
Page<User> findByStatus(String status, Pageable pageable);
Slice<User> ...
List<User>  ...
```


## `@Query`, JPQL

JPQL(Java Persistence Query Language)는 엔티티 모델(객체지향 모델)을 대상으로 하는 데이터베이스 쿼리 언어이다

SQL처럼 테이블/컬럼을 직접 다루는 대신 엔티티 이름과 필드 이름을 기준으로 쿼리한다 (엔티티에 이름을 명시한 경우 해당 이름으로만 쿼리할 수 있다)

JPA 표준으로 벤더 독립적 표현을 제공하고 하이버네이트같은 구현체가 SQL로 변환한다

`@Query`는 스프링 데이터 JPA에서 리포지토리 메서드에 직접 JPQL이나 SQL을 작성할 수 있도록 제공하는 어노테이션이다

문자열 기반이라 컴파일 시점에 타입 체크를 할 수 없기 때문에 런타임 오류가 발생할 수 있다

**기본 구조**

```java
@Query("SELECT u FROM User u WHERE u.status = :status") // 명명된 파라미터
List<User> findByStatus(@Param("status") String status);

@Query("SELECT u FROM User u WHERE u.status = ?1") // 위치 파라미터
List<User> findByStatus(String status);
```

파라미터 바인딩은 명명된 파라미터 바인딩(`:status`)과 위치 파라미터(`?1`)를 지원한다
- `:status`: 네임드 파라미터 바인딩
- `@Param("status")`: 메서드 파라미터와 매핑

**네이티브 쿼리**

nativeQuery 속성을 활성화하면 JPQL 대신 실제 SQL을 사용한다

```java
@Query(value = "SELECT * FROM users WHERE status = :status", nativeQuery = true)
List<User> findByStatusNative(@Param("status") String status);
```

**카운트 쿼리**

`Page<T>` 반환 타입일 때 페이징 처리를 위해 별도의 카운트 쿼리를 지정할 수 있다

지정하지 않으면 `@Query`에 작성한 쿼리를 기반으로 자동 생성한다

```java
@Query(
        value = "SELECT u FROM User u WHERE u.status = :status",
        countQuery = "SELECT COUNT(u) FROM User u WHERE u.status = :status"
)
```

### `@Query` 실행 흐름

스프링 컨텍스트 초기화 시
- 리포지토리 인터페이스 스캔
- `@Query` 어노테이션 메서드를 `JpaQueryMethod` - `StringQuery` 객체로 생성
  - JPQL 문법 파싱/검증 수행 (네이티브 쿼리의 경우 검증 불가, 런타임 오류 발생 가능)

런타임
- 메서드별로 파싱된 JPQL 캐싱
- 메서드 호출 시 하이버네이트가 캐싱된 JPQL을 SQL로 변환
- 파라미터 바인딩(PreparedStatement) 후 SQL 실행

### 벌크 업데이트/삭제

JPQL은 업데이트나 삭제에 대한 벌크 연산을 지원한다

```java
@Query("UPDATE User u SET u.status = 'INACTIVE' WHERE u.lastLogin < :cutoff")
```

**벌크 연산은 영속성 컨텍스트(1차 캐시)를 우회해서 DB에 직접 반영한다**

따라서 영속성 컨텍스트에 이미 로드된 엔티티와 DB 상태가 불일치할 수 있다

이 경우 영속성 컨텍스트를 비우거나 관련된 엔티티들을 직접 동기화(재조회)해야 한다

### 권장사항

N+1 문제: 페치 조인, 엔티티 그래프, DTO 프로젝션

대량 읽기: DTO 프로젝션으로 메모리 절약

대량 쓰기: 벌크 연산 후 영속성 컨텍스트 정리/동기화

복잡한 조건/동적 쿼리: Querydsl, Criteria

count 쿼리 최적화: 페이징용 count 쿼리를 단순화해서 countQuery 직접 지정

쿼리 힌트: timeout, cacheable 등 사용

프로파일링: SQL 로그와 실행 계획(`EXPLAIN`) 확인


## `@Modifying`

일반적으로 스프링 데이터 JPA는 `@Query`를 조회용 쿼리로 인식한다

그래서 `UPDATE`, `DELETE`, `INSERT` 같은 데이터 조작 언어(DML)를 작성하면 JPA는 조회로 착각하고 실행하려다 오류가 발생하게 된다

JPA에게 데이터 변경 쿼리임을 알려주기 위해 `@Modifying` 어노테이션을 사용한다

```java
public interface UserRepository extends CrudRepository<User, Long> {
    
    // 반환 타입 int: 영향받은 row 개수 리턴
    @Modifying
    @Query("UPDATE User u SET u.status = :status WHERE u.id = :id")
    int updateUserStatus(@Param("id") Long id, @Param("status") String status);
    
    @Modifying
    @Query("DELETE FROM User u WHERE u.lastLogin < :cutoff")
    int deleteInactiveUsers(@Param("cutoff") LocalDateTime cutoff);
}
```

`clearAutomatically` 속성을 활성화하면 쿼리 실행 후 영속성 컨텍스트를 자동으로 비운다

기본값은 false라서 업데이트한 값이 1차 캐시에 반영되지 않아 데이터 불일치 문제가 발생할 수 있다

`flushAutomatically` 속성을 활성화하면 쿼리 실행 전 영속성 컨텍스트의 상태를 데이터베이스에 반영한다


## 페이징

데이터베이스에서 지원하는 일반적인 페이징 방식 종류는 다음과 같다

![pagination](https://assets.bytebytego.com/diagrams/0076-api-pagination-101.png)

[출처](https://bytebytego.com/guides/how-do-we-perform-pagination-in-api-design/)

**Offset/Page 페이지네이션**

가장 흔한 방식으로 특정 레코드의 페이지를 선택하기 위해 시작 위치를 나타내는 `OFFSET`과 가져올 개수 `LIMIT`절을 조합한다

간단하고 직관적이지만 대용량 데이터베이스인 경우 `OFFSET`의 값이 커지면 앞에 있는 N개의 레코드를 스킵하느라 성능이 저하된다

```mysql
SELECT * 
FROM users 
LIMIT 10 
OFFSET 20;
```

**Cursor/Keyset 페이지네이션**

현재 페이지에 있는 마지막 레코드의 타임스탬프나 ID와 같이 고유한 값을 나타내는 커서를 사용하여 다음 레코드들을 가져온다

`OFFSET`으로 인한 레코드 스킵이 없으므로 대량 데이터 조회 시 더 좋은 성능을 보인다

다만 임의의 특정 페이지로 이동할 수 없기 때문에 무한 스크롤 구현할 때 사용하기 적합하다

```mysql
SELECT *
FROM users
WHERE id > 100
ORDER BY id
LIMIT 10;
```

### 스프링 데이터 페이지네이션 컴포넌트

**쿼리에서 사용되는 컴포넌트(요청)**
- `Pageable`: 쿼리 메서드(메서드 이름 기반, `@Query`)에 동적 페이징 조건을 지정한다
- `Sort`: 정렬 조건 지정
- `Limit`: 결과 개수 제한
- `ScrollPosition`: 스크롤 위치 지정 (Offset/Keyset, 앞/뒤 방향 지정 가능)

`Pageable` 안에 `Sort`와 `Limit`가 이미 정의되어 있다

또한 결과 수를 제한하는 `Top`와 `Pageable`이 같이 사용될 수 있지만 `Top`은 결과의 최대 수를 정의하고, `Pageable`은 그 수를 줄이게 될 수 있다

**쿼리 결과 컴포넌트(응답)**
- `List`: 카운트 쿼리가 발생하지 않고 쿼리가 지정된 범위의 엔티티만 조회하도록 제한된다
- `Page`: 데이터셋(페이지)과 요소의 전체 개수를 알고 있는 조회 결과 값 (카운트 쿼리 발생)
- `Slice`: 데이터셋(다음 슬라이스를 가져올 수 있는지 여부만 알고 있다, 카운트 쿼리 발생 X)
- `Window`: 데이터셋(다음 윈도우 존재 여부, 특정 인덱스 ScrollPosition 제공 등)

### 페이지네이션 쿼리 메서드의 반환 타입 선택 가이드

[스프링 공식 문서](https://docs.spring.io/spring-data/jpa/reference/repositories/query-methods-details.html#repositories.scrolling.guidance)

|반환 타입|데이터 조회량|쿼리 구조|참고사항|
|---|---|---|---|
|`List<T>`|모든 결과|단일 쿼리|조회 시간이 길어질 수 있고 쿼리 결과로 인해 모든 메모리가 소비될 수 있다|
|`Streamable<T>`|모든 결과|단일 쿼리|`List<T>`와 동일|
|`Stream<T>`|청크(하나씩 or 배치)|커서를 사용한 단일 쿼리|사용을 마치면 리소스 누출 방지를 위해 스트림을 닫아야 한다|
|`Flux<T>`|청크(하나씩 or 배치)|커서를 사용한 단일 쿼리|리액티브 제공 필수|
|`Slice<T>`|`Pageable.getOffset()`부터 `Pageable.getPageSize() + 1`까지|1~N개 쿼리|`Slice`는 오직 다음 `Slice`만을 가리킬 수 있다 - 다음에 조회할 수 있는 데이터가 있는지 확인 가능, Offset 값이 너무 큰 경우 스킵으로 인해 쿼리가 비효율적으로 동작한다|
|`Page<T>`|`Pageable.getOffset()` 부터 `Pageable.getPageSize()`까지|1~N개 쿼리, 카운트 쿼리|Offset 값이 너무 큰 경우 스킵으로 인해 쿼리가 비효율적으로 동작한다, 종종 카운트 쿼리가 비용을 유발|
|Offset 기반 `Window<T>`|`OffsetScrollPosition.getOffset()`부터 `limit+1`까지|1~N개 쿼리|`Window`는 오직 다음 `Window`만을 가리킬 수 있다 - 다음에 조회할 수 있는 데이터가 있는지 확인 가능, Offset 값이 너무 큰 경우 스킵으로 인해 쿼리가 비효율적으로 동작한다|
|Keyset 기반 `Window<T>`|`WHERE` 조건문으로 필터링된 결과수를 기반으로 `limit+1`|1~N개 쿼리|`Window`는 오직 다음 `Window`만을 가리킬 수 있다 - 다음에 조회할 수 있는 데이터가 있는지 확인 가능, 적절한 인덱스 구조 설정 필요|

### 예시 엔티티 및 리포지토리

```java
@Entity(name = "paginationBook")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class PBook {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    private LocalDate publishedAt;

    public Book(String name, LocalDate publishedAt) {
        this.name = name;
        this.publishedAt = publishedAt;
    }   
}
```

```java
@Repository("paginationBookRepository")
public interface PBookRepository extends JpaRepository<PBook, Long> {

    @Query("SELECT b FROM paginationBook b")
    List<Book> findAllToList(Pageable pageable);


    @Query("SELECT b FROM paginationBook b")
    Page<Book> findAllToPage(Pageable pageable);


    @Query("SELECT b FROM paginationBook b")
    Slice<Book> findAllToSlice(Pageable pageable);

    Window<PBook> findAllBy(Pageable pageable, ScrollPosition position);

}
```

### `List<T>` Offset 페이지네이션

```java
// booksTotalSize: 1000
// 오프셋 0 조회 소요 시간: 54ms
// 쿼리 1번 발생: 조회
@Test
void zeroOffset_20Size_list() {
    long start = System.currentTimeMillis();
    List<Book> books = repository.findAllToList(PageRequest.of(0, 20));
    long elapsedTime = System.currentTimeMillis() - start;
    
    assertThat(books).hasSize(20);
    assertThat(stat.getQueryExecutionCount()).isEqualTo(1);
    System.out.println("list(0 offset) elapsed time: " + elapsedTime + "ms");
}
```

### `Page<T>` Offset 페이지네이션

`getPageable().getOffset()` == `getNumber()` == logical offset

`getPageable().getPageSize()` == `getNumberOfElements()` == limit

데이터베이스 오프셋: 논리 오프셋 * 페이지 사이즈

만약 논리 오프셋(페이지 넘버)가 10이고 limit(페이지 사이즈)가 20이라면 데이터베이스 오프셋은 200이 된다

오프셋 0부터 199까지 레코드를 스킵한 뒤 20개(limit)를 읽어들인다

```java
// booksTotalSize: 1000
// 오프셋 0 조회 소요 시간: 66ms
// 쿼리 2번 발생: 조회, 카운트
// 논리적 오프셋(페이지 넘버): 0
// 물리적 오프셋(데이터베이스): 0
@Test
void zeroOffset_20Size_page() {
    long start = System.currentTimeMillis();
    Page<Book> books = repository.findAllToPage(PageRequest.of(0, 20));
    long elapsedTime = System.currentTimeMillis() - start;
    
    assertThat(books.getContent()).hasSize(20);
    assertThat(books.getTotalElements()).isEqualTo(booksTotalSize);
    assertThat(books.hasContent()).isTrue();
    assertThat(books.hasNext()).isTrue();
    assertThat(books.hasPrevious()).isFalse();
    assertThat(stat.getQueryExecutionCount()).isEqualTo(2);
    System.out.println("number: " + books.getNumber());
    System.out.println("number of elements: " + books.getNumberOfElements());
    // page number == logical offset
    // page size == limit == number of elements
    System.out.println("page(0 offset) elapsed time: " + elapsedTime + "ms");
}
```

```java
// booksTotalSize: 1000
// 오프셋 절반(25) 조회 소요 시간: 85ms 
// 논리적 오프셋(페이지 넘버): 25
// 물리적 오프셋(데이터베이스): 500
@Test
void halfOffset_20size_page() {
    long start = System.currentTimeMillis();
    Page<Book> books = repository.findAllToPage(PageRequest.of((booksTotalSize/20)/2, 20));
    long elapsedTime = System.currentTimeMillis() - start;
    
    // ....
    System.out.println("elapsed time: " + elapsedTime + "ms");
}
```

```java
// booksTotalSize: 1000
// 오프셋 마지막(49) 조회 소요 시간: 60ms 
// 논리적 오프셋(페이지 넘버): 49
// 물리적 오프셋(데이터베이스): 980
@Test
void lastOffset_20size_page() {
    long start = System.currentTimeMillis();
    Page<Book> books = repository.findAllToPage(PageRequest.of(booksTotalSize/20-1, 20));
    long elapsedTime = System.currentTimeMillis() - start;
    
    // ...
    System.out.println("elapsed time: " + elapsedTime + "ms");
}
```

### `Slice<T>` Offset 페이지네이션

```java
// booksTotalSize: 1000
// 쿼리 발생 1회: 조회 
// 오프셋 0 조회 소요 시간: 56ms 
@Test
void zeroOffset_20Size_slice() {
    long start = System.currentTimeMillis();
    Slice<Book> books = repository.findAllToSlice(PageRequest.of(0, 20));
    long elapsedTime = System.currentTimeMillis() - start;   

    assertThat(books.getContent()).hasSize(20);
    assertThat(books.getNumber()).isEqualTo(0);
    assertThat(books.hasContent()).isTrue();
    assertThat(books.hasNext()).isTrue();
    assertThat(books.hasPrevious()).isFalse();   
    assertThat(stat.getQueryExecutionCount()).isEqualTo(1);
    System.out.println("slice(0 offset) elapsed time: " + elapsedTime + "ms");
}
```

### `Window<T>` Offset 페이지네이션

```java
@Test
void firstOffset_20Size_window() {
    long start = System.currentTimeMillis();
    Window<PBook> books = repository.findAllBy(PageRequest.ofSize(20), ScrollPosition.offset());
    long elapsedTime = System.currentTimeMillis() - start;   

    assertThat(books.getContent()).hasSize(20);
    assertThat(books.getContent().getFirst().getId()).isEqualTo(1);
    assertThat(books.hasNext()).isTrue();
    assertThat(books.isLast()).isFalse();
    assertThat(stat.getQueryExecutionCount()).isEqualTo(1);
    System.out.println("slice(0 offset) elapsed time: " + elapsedTime + "ms");        
}
```

### `Window<T>` Keyset 페이지네이션

```java
@Test
void scrollKeysetForwardWithId_window() {
    long start = System.currentTimeMillis();
    Window<PBook> books = repository.findAllBy(PageRequest.ofSize(20), ScrollPosition.keyset());
    int totalFetchSize = books.size();

    // Book 엔티티의 id 필드를 기준으로 키 셋 페이지네이션
    while (books.hasNext()) {
        PBook lastBook = books.getContent().getLast();
        ScrollPosition nextPosition = books.positionAt(lastBook); // 아래 코드와 동일하다
        // ScrollPosition nextPosition = ScrollPosition.forward(Map.of("id", lastBook.getId()));
        books = repository.findAllBy(PageRequest.ofSize(20), nextPosition);
        totalFetchSize += books.size();
    }   
    long elapsedTime = System.currentTimeMillis() - start;

    assertThat(totalFetchSize).isEqualTo(1000);
    System.out.println("elapsed time (keyset forward): " + elapsedTime + "ms");
    System.out.println("total query execution count:" + stat.getQueryExecutionCount());
}
```

```java
// WindowIterator를 활용하여 반복문 제거
@Test
void scrollSpecificKeyset_windowIterator() {
    long start = System.currentTimeMillis();
    Sort.TypedSort<PBook> bookSort = Sort.sort(PBook.class);
    Sort sort = bookSort.by(PBook::getPublishedAt).descending();

    WindowIterator<PBook> books = WindowIterator
            .of(position -> repository.findAllBy(PageRequest.ofSize(20).withSort(sort), position))
            .startingAt(ScrollPosition.forward(Map.of("id", 500L, "publishedAt", LocalDate.of(2025, 05, 31))));
    
    List<PBook> result = new ArrayList<>();
    books.forEachRemaining(result::add);
    long elapsedTime = System.currentTimeMillis() - start;

    System.out.println("total fetch size: " + result.size());
    System.out.println("elapsed time (keyset backward): " + elapsedTime + "ms");
}
```


## 정렬

`PageRequest`: 페이징, 정렬 정보를 캡슐화한 `Pageable` 구현체

`Sort`: N개의 `Order`를 포함한 객체 (최종 정렬 정보)

`Order`: 특정 엔티티 프로퍼티의 정렬 설정 (`ascending()`, `desceding()`, `ignoreCase()`, `nullsFirst()`, `nullsLast()`)

`TypedSort`, `TypedOrder`: 타입 세이프한 정렬 설정

```java
PageRequest pr = PageRequest.of(
    0,  // page number
    20, // page size
    Sort.sort(User.class)  // username 오름차순 - createdAt 내림차순 정렬
        .by(User::getUsername).ascending()
        .and(Sort.sort(User.class).by(User::getCreatedAt).descending())
);
```


## 커스텀 리포지토리

메서드 이름 기반 쿼리, `@Query` 등 스프링 데이터 JPA가 제공하는 기능으로 복잡한 쿼리를 수행하기 부족할 때 커스텀 리포지토리를 통해 이를 보충할 수 있다

커스텀 리포지토리를 사용하면 Querydsl 등의 기술을 사용하여 타입 세이프한 쿼리를 만들거나 재사용 가능한 데이터 액세스 로직을 구성할 수 있다

**동작 과정**
- 커스텀 리포지토리 인터페이스 정의
- 커스텀 리포지토리 인터페이스 구현
- 메인 리포지토리 인터페이스 -> 커스텀 리포지토리 인터페이스 확장
- 사용

```java
// 커스텀 리포지토리 인터페이스 정의
// 보통 XXXRepositoryCustom 형식으로 네이밍한다
public interface UserRepositoryCustom {
    List<User> findActiveUsersCreatedAfter(LocalDateTime date);
}
```

```java
// 커스텀 리포지토리 인터페이스 구현
// 스프링 데이터 JPA가 인식할 수 있도록 클래스명에 접미사를 무조건 붙여야 한다
// 기본 접미사: Impl
// 접미사 수정: @EnableJpaRepositories(repositoryImplementationPostfix = "CustomImpl")
public class UserRepositoryImpl implements UserRepositoryCustom {

    @Override
    List<User> findActiveUsersCreatedAfter(LocalDateTime date) {
        // ...
    }
}
```

```java
// 메인 리포지토리 인터페이스 -> 커스텀 리포지토리 인터페이스 확장
public interface UserRepository extends JpaRepository<User, Long>, UserRepositoryCustom
```

```java
List<User> users = userRepository.findActiveUsersCreatedAfter(LocalDateTime.now());
```


## 페이지네이션과 `@OneToMany` 성능저하 이슈

```java
public interface UserRepository extends JpaRepository<User, Long> {

    @Query("SELECT u FROM users u JOIN FETCH u.orders")
    List<User> findUsers(Pageable pageable);
}
```

페이지네이션을 수행하는 쿼리에서 `@OneToMany` 연관관계를 가지는 엔티티를 기준으로 페치조인을 하면 두 엔티티가 조인을 수행하고 원래 단 건이어야 하는 `@OneToMany` 엔티티가 여러 `@ManyToOne` 엔티티로 인해 raw 중복이 발생한다 (JPA가 `LIMIT/OFFSET`을 걸기 전에 발생한다)

중복된 레코드들은 메모리에 모두 로드되고 하이버네이트가 자체적으로 중복 제거를 진행한다

이 때 하이버네이트는 `org.hibernate.orm.query: HHH90003004: firstResult/maxResults specified with collection fetch; applying in memory` 인메모리 페이지네이션 경고 메시지를 출력한다

페치조인을 안쓴다고 하더라도 `@OneToMany`에 연관된 엔티티들을 가져와야 하기 때문에 N+1 문제가 발생한다

이를 해결할 수 있는 방법은 다음과 같다

### 1. `@BatchSize`

일대다 엔티티 조회 -> 연관 엔티티 조회 시 일정 크기 일괄 로딩

```java
// 페치조인없이 유저 엔티티만 조회
Page<User> page = userRepository.findAll(pageable);
```

```java
// 유저 엔티티를 통해 주문 엔티티 접근 시 지연 로딩 -> 배치 사이즈만큼 일괄 로딩
@Entity(name = "users")
public class User {

    @OneToMany(mappedBy = "users")
    @BatchSize(size = 100) // 100개씩 IN 쿼리로 묶어서 일괄적으로 로딩
    private List<Order> orders;
}
```

### 2. DTO 프로젝션

일대다 엔티티와 필요한 연관 엔티티 필드 조회

```java
@Query("SELECT new com.example.UserOrderDTO(u.id, u.name, o.id, o.amount) " +
       "FROM User u LEFT JOIN u.orders o " +
       "WHERE u.active = true")
Page<UserOrderDTO> findUserOrders(Pageable pageable);
```


## 삽입/업데이트/삭제 배치 처리

삽입 배치 최적화 (`IDENTITY`인 경우 벌크 삽입 불가)

```yaml
spring:
  jpa:
    properties:
      hibernate:
        jdbc:
          batch_size: 50    # 20 ~ 50
        order_inserts: true # 같은 테이블 insert 일괄 처리
        order_updates: true # 같은 테이블 update 일괄 처리 
```

대량 업데이트/삭제 (영속성 컨텍스트 동기화 필요)

```java
@Modifying
@Query("UPDATE bulkAccount a SET a.activated = FALSE WHERE a.lastLogin < :limit ")
int bulkUpdateInactivated(@Param("limit") LocalDateTime limit);
```