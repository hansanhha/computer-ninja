#### 인덱스
- [스프링 배치 파티셔닝](#스프링-배치-파티셔닝)
- [컴포넌트](#컴포넌트)
  - [Master Step](#master-step)
  - [PartitionHandler](#partitionhandler)
  - [Worker Step](#worker-step)
  - [StepExecutionAggregator](#stepexecutionaggregator)
- [동작 흐름](#동작-흐름)
  - [유의사항](#유의사항)


## 스프링 배치 파티셔닝

스프링 배치는 기본적으로 청크를 순차적으로 처리하는 방식으로 동작하기 때문에 대규모 데이터를 처리할 때 비효율적인 리소스(CPU) 사용과 느린 성능, 제한적인 스케일링 등의 한계를 가진다

스프링 배치 파티셔닝은 워크로드를 분할하고 대규모 데이터를 여러 청크로 소분화하여 이를 동시다발적으로 처리할 수 있게 해준다

**즉, 하나의 큰 처리 단위를 여러 작은 파티션으로 분리해서 병렬로 처리하고 모든 파티션이 완료되면 Job이 최종적으로 성공으로 종료되는 구조를 가진다**

기존 순차적인 실행보다 CPU 활용과 처리 속도를 대폭 향상시키고 스케일링을 효율적으로 할 수 있으며, 단일 트랜잭션이 아닌 파티션별로 독립 트랜잭션을 가진다


## 컴포넌트

```text
Master Step (Partitioner, Map<String, ExeuctionContext>)
 ├── PartitionHandler
 │     ├── Worker Step #1 (Thread 1, ExecutionContext-0)
 │     ├── Worker Step #2 (Thread 2, ExecutionContext-1)
 │     ├── Worker Step #3 (Thread 3, ExecutionContext-2)
 │     └── ...
 └── StepExecutionAggregator (결과 병합)
```

### Master Step
- 전체 파티션을 관리하는 Step(PartitionStep) 이다
- Job이 Master Step을 시작하면 내부적으로 Partitioner가 호출되어 여러 개의 ExecutionContext(파티션별 데이터 구간 정보)를 생성한다
- 대규모 데이터를 각 파티션에 대해 StepExecution을 생성하면 이를 Worker Step에서 처리한다
- StepExecution: 동일한 Step 정의를 가지고 서로 다른 ExecutionContext로 실행되는 독립적인 Step들
- Worker Step은 PartitionHandler에 의해 제어된다

### Partitioner
- 각 WorkerStep이 실행할 파티션 정보(ExecutionContext)를 만든다
- 스프링 배치의 StepExeuctionSplitter가 `Map<String, ExecutionContext>`를 이용하여 StepExecution을 생성한다

```java
public class ColumnRangePartitioner implements Partitioner {

    @Override
    public Map<String, ExecutionContext> partition(int gridSize) {
        Map<String, ExecutionContext> partitions = new HashMap<>();

		// 총 500개의 컬럼
        int min = 1;
        int max = 500;

		// gridSize=3인 경우, 각 WorkerStep은 166개 처리
        int range  = (max - min) / gridSize;
        int start = min;
        int end = start + range;

		// partitions 0 - start: 1,   end: 167
		// partitions 1 - start: 168, end: 334
		// partitions 2 - start: 355, end: 500
        for (int i = 0; i < gridSize; i++) {
            ExecutionContext context = new ExecutionContext();
            context.putInt("start", start);
            context.putInt("end", end);
            partitions.put("partitions" + i, context);
            start = end + 1;
            end = (i == gridSize - 2) ? max : end + range;
        }

        return partitions;
    }
    
}
```

```text
// 각자의 ExecutionContext를 갖는 StepExecution
// 각각은 동일한 WorkerStep 정의를 사용한다 

StepExecution[partition0] : ExecutionContext {start=1, end=167}
StepExecution[partition1] : ExecutionContext {start=168, end=334}
StepExecution[partition2] : ExecutionContext {start=335, end=500}
```

### PartitionHandler
- StepExecution들을 병렬적으로 실행하는 핸들러
- TaskExecutorPartitionHandler: 동일 JVM 내에서 멀티 스레드를 통해 동시 실행한다
- MessageChannelPartitionHandler: 메시징 시스템을 통해 원격으로 동시 실행한다

### Worker Step (StepExecution)
- 실제 아이템을 읽고 처리하는 동작 과정을 정의하는 Step (Reader->Processor->Writer 또는 Tasklet)
- Partitioner에 의해 나눠진 파티션을 갖는 모든 StepExecution들은 동일한 Worker Step을 공유한다
- 각 StepExecution은 별도의 스레드에서 동작하므로 StepExecutionContext를 통해 해당 스레드가 처리할 범위의 데이터만 조회하는 ItemReader를 초기화한다
- 즉, ItemReader는 `@StepScope`가 붙어 있으므로 각 StepExecution 별로 새롭게 생성된다
- 또한 StepExecution은 독립된 트랜잭션을 가진다
- `#{stepExecutionContext['start']}`는 해당 StepExecution의 ExecutionContext에 저장된 값을 자동으로 읽는다

```java
@Bean
@StepScope
JdbcPagingItemReader<Person> reader(
    @Value("#{stepExecutionContext['start']}") Integer start,
    @Value("#{stepExecutionContext['end']}") Integer end) {

	return new JpaPagingItemReaderBuilder<Person>()
		.name("reader")
		.entityManagerFactory(emf)
		.queryString("SELECT p FROM Person p WHERE p.id BETWEEN :start AND :end")
		.parameterValues(Map.of("start", start, "end", end))
		.pageSize(20)
		.build();
}
```

각 파티션은 자신의 범위 데이터만 읽는다
- Thread-1: `id BETWEEN 1   AND 167`
- Thread-2: `id BETWEEN 168 AND 334`
- Thread-3: `id BETWEEN 335 AND 550`

이렇게 각 스레드가 독립적으로 chunk 단위로 Reader -> Processor -> Writer를 수행한다
- 메모리 간섭 X (ExecutionContext 분리됨)
- 실패 시 해당 파티션만 재시도 가능
- 각 파티션 단위로 독립적인 트랜잭션

### StepExecutionAggregator 또는 TaskExecutorPartitionHandler
- 모든 StepExecution이 완료되면 결과를 취합하여 MasterStep의 최종 상태를 결정한다
- 하나라도 실패하면 MasterStep 전체가 실패로 간주된다


## 동작 흐름

```text
    Master Step 실행
            ↓
Partitioner가 특정 기준을 기반으로 여러 파티션 정의
(각 파티션은 독립된 ExecutionContext를 가짐 - minId, maxId 등)
            ↓
PartitionHandler가 Worker Step을 병렬로 실행
(보통 TaskExecutorPartitionHandler 스레드풀 실행)
            ↓
각 Worker Step이 자신의 데이터 처리
            ↓
모든 파티션 완료 시 StepExecutionAggregator가 결과를 모아 Worker Step 종료
```

### 유의사항

ID, 날짜, 지역 등 데이터를 균등하게 나눌 수 있는 컬럼을 사용한다

파티션 간 데이터 범위가 겹치지 않도록 한다

CPU 코어 수보다 많은 파티션을 가지면 컨텍스트 스위칭 오버헤드가 발생한다


