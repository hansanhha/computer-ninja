#### 인덱스
- [개요](#개요)
- [ItemProcessor 구현](#itemprocessor-구현)
- [Tasklet 구현](#tasklet-구현)
- [컴포넌트 구성](#컴포넌트-구성)
- [컨트롤러 구현](#컨트롤러-구현)


## 개요

Person 엔티티를 데이터베이스로부터 읽어서 `firstName`과 `lastName` 필드를 조합한 PersonAfterProcess 엔티티를 생성하고 DB에 저장하는 예시

**스프링 배치 5 버전부터 `@EnableBatchProcessing` 어노테이션을 생략해야 정상적으로 동작한다**

[그레이들 빌드](../build.gradle.kts)

[소스 코드](../src/main/java/hansanhha/basic)

[프로퍼티 및 SQL 파일](../src/main/resources/)


## ItemProcessor 구현

스프링 배치에서 제공하는 `ItemProcessor` 인터페이스를 구현한다

Person 엔티티를 받아서(Step 내부에서 `ItemReader`를 통해 전달받음) `firstName`과 `lastName`을 조합한 PersonAfterProcess 엔티티를 반환한다

```java
@Component
public class PersonProcessor implements ItemProcessor<Person, PersonAfterProcess>{

    @Override
    public PersonAfterProcess process(Person person) throws Exception {
        var item = new PersonAfterProcess(person.getFirstName() + " " + person.getLastName());
        return repository.save(item);
    }
    
}
```


## Tasklet 구현

스프링 배치에서 제공하는 `Tasklet` 인터페이스를 구현한다

Job이 끝나면 단순한 콘솔 로그를 출력하고 `RepeatStatus.FINISHED`을 반환하여 현재 Step을 반복 실행하지 않도록 한다

```java
@Component
public class LogTasklet implements Tasklet {

    @Override
    public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {
        System.out.println("Job completed successfully");
        return RepeatStatus.FINISHED;
    }
    
}
```


## 컴포넌트 구성

`ItemReader`에서 사용할 엔티티 매니저 팩토리, 위에서 등록한 `ItemProcessor`와 `Tasklet` 구현체를 의존성 주입받는다

```java
@Configuration
// 스프링 배치 5 버전 이후부터 아래의 어노테이션 생략
// @EnableBatchProcessing
public class BatchConfig {
    
    private final EntityManagerFactory emf;
    private final ItemProcessor<Person, PersonAfterProcess> personProcessor;
    private final LogTasklet logTasklet;

    // ...
}
```

**`ItemReader` 설정**: 배치 처리할 Person 엔티티를 페치한다

구현체: `JpaPagingItemReader`

Person 엔티티를 가져오기 위한 JPQL 쿼리와 사이즈를 설정한다

```java
@Bean
JpaPagingItemReader<Person> reader() {
    return new JpaPagingItemReaderBuilder<Person>()
            .name("personItemReader")
            .entityManagerFactory(emf)
            .queryString("SELECT p FROM Person p")
            .pageSize(10)
            .build();
}
```

**`ItemWriter` 설정**: 청크 단위로 쓰기 작업을 일괄적으로 커밋하고 트랜잭션을 제어한다

구현체: `JpaItemWriter`

`PersonProcessor`에 의해 `PersonAfterProcess` 타입 엔티티들을 청크 단위로 DB에 저장한다

```java
@Bean
JpaItemWriter<PersonAfterProcess> writer() {
    JpaItemWriter<PersonAfterProcess> writer = new JpaItemWriter<>();
    writer.setEntityManagerFactory(emf);
    return writer;
}
```

**`Step` 설정 1**: `Person` -> `PersonAfterProcess` 작업 설정 (데이터 페치, 가공, 저장할 컴포넌트와 청크 단위)

Reader가 Person 엔티티를 10건씩 읽으면 Processor가 각각 PersonAfterProcess로 변환한다 (아직 DB 저장 X)

이후 Writer를 통해 10건의 변환된 엔티티를 일괄적으로 영속 및 플러시한다

그리고 다음 청크로 이동하면서 작업을 이어간다

```java
@Bean
Step stepPersonChunk(JobRepository jobRepository, PlatformTransactionManager txManager) {
    return new StepBuilder("stepPersonChunk", jobRepository)
        .<Person, PersonAfterProcess>chunk(10, txManager)
        .reader(reader())
        .processor(personProcessor)
        .writer(writer())
        .build();
}
```

**`Step` 설정 2**: 엔티티 변환 작업을 마치면 성공적으로 완료했다는 콘솔 로그를 남기는 `Tasklet` Step을 빈으로 등록한다

```java
@Bean
Step taskletStep(JobRepository jobRepository, PlatformTransactionManager txManager) {
    return new StepBuilder("taskletStep", jobRepository)
        .tasklet(logTasklet, txManager)
        .build();
}
```

**Job 설정**: 엔티티를 변환하는 Step을 가장 먼저 시작하고 그 다음 콘솔 로그 작업을 수행하는 Step을 등록한다

```java
@Qualifier("processPersonJob")
@Bean
Job processPersonJob(
    JobRepository jobRepository, 
    @Qualifier("personProcessStep") Step personProcessStep, 
    @Qualifier("logStep") Step logStep) {

    return new JobBuilder("processPersonJob", jobRepository)
            .start(personProcessStep)
            .next(logStep)
            .build();
}
```


## 컨트롤러 구현

```java
@RestController
@RequestMapping("/api/jobs")
public class JobController {

    private final JobLauncher jobLauncher; // Job 실행 엔진
    private final JobRepository jobRepository; // Job 조회
    private final Job processPersonJob; // 실행할 Job

    public JobController(JobLauncher jobLauncher, JobRepository jobRepository, @Qualifier("processPersonJob") Job job) {
        this.jobLauncher = jobLauncher;
        this.jobRepository = jobRepository;
        this.processPersonJob = job;
    }

    // 요청이 들어오는 시점에 JobParameters에 현재 시스템 시간을 바인딩하여 JobInstance를 구분한다
    // Job과 JobParameters를 JobLauncher에게 전달하여 실행한다 
    @SuppressWarnings("unchecked")
    @GetMapping("/simple/run")
    public ResponseEntity<String> runJob() {
        try {
            JobParameters jobParameters = new JobParametersBuilder()
                    .addLong("timestamp", System.currentTimeMillis())
                    .toJobParameters();

            
            JobExecution jobExecution = jobLauncher.run(processPersonJob, jobParameters);
            JobInstance jobInstance = jobExecution.getJobInstance();

            return ResponseEntity.ok(
            """
            Job started successfully
            name: %s
            status: %s
            timestamp: %s
            """.formatted(
                jobInstance.getJobName(),
                jobExecution.getStatus(),
                jobParameters.getLong("timestamp")
            ));
        } catch (Exception e) {
            return ResponseEntity.status(500).body(processPersonJob.getName() + " job failed to start: " + e.getMessage());
        }
    }

    // 실행된 JobExecution의 상세 정보 조회
        @GetMapping("/{name}/{timestamp}")
    public ResponseEntity<String> getJob(@PathVariable String name, @PathVariable Long timestamp) {
        JobParameters jobParameters = new JobParametersBuilder()
                    .addLong("timestamp", timestamp)
                    .toJobParameters();

        JobInstance jobInstance = jobRepository.getJobInstance(name, jobParameters);
        JobExecution jobExecution = jobRepository.getLastJobExecution(name, jobParameters);
        Collection<StepExecution> stepExecutions = jobExecution.getStepExecutions();

        return ResponseEntity.ok(
            """
            JOB INSTANCE DETAILS
            - id: %d
            - version: %d

            JOB EXECUTION DETAILS
            - create time: %s
            - start time: %s
            - end time: %s
            - elasped time: %s
            - status: %s

            STEP EXECUTIONS
            %s
            """.formatted(
                jobInstance.getInstanceId(), 
                jobInstance.getVersion(),
                jobExecution.getCreateTime(),
                jobExecution.getStartTime(),
                jobExecution.getEndTime(),
                jobExecution.getEndTime() != null && jobExecution.getStartTime() != null ?
                    (jobExecution.getEndTime().getNano() - jobExecution.getStartTime().getNano()) / 1_000_000 + "ms" : "N/A",
                jobExecution.getExitStatus(),
                stepExecutions.stream().map(StepExecution::getSummary).map(s -> Strings.concat("- ", s)).collect(Collectors.joining("\n\n"))
                )
        );
    }
       
}
```