[서버 코드](./server.c)

[1000개 클라이언트 연결 테스트 코드](./test.py)

```shell
clang ./server -o server
python ./test.py
```

## Blocking I/O 모델의 한계

기본 I/O 모델

```text
recv() -> 데이터 올 때까지 블로킹
send() -> 버퍼가 비워질 때까지 블로킹
accept() -> 클라언트 연결 오기 전까지 블로킹
```

[thread-per-client](../../echo-server_thread-per-client/c)는 이러한 블로킹을 클라이언트 요청마다 스레드를 생성하여 회피했다

그러나 클라이언트 수가 늘어나는 만큼 스레드 수가 증가하고 이에 따라 스택 메모리, 컨텍스트 스위칭 비용, OS 스케줄링 부하가 심해진다

## I/O 멀티플렉싱

멀티플렉싱(Multiplexing)은 다중화라는 의미로 통신 분야에서 하나의 통신 채널을 통해 여러 신호나 스트림을 동시에 전송하는 기술을 일컫는다

서버 관점에서는 **하나의 스레드(프로세스)가 여러 개의 소켓(File Descriptor)을 동시에 모니터링하다가, 입출력이 가능한 상태가 된 소켓만 골라내어 처리하는 방식**을 말한다

멀티 스레드 vs I/O 멀티플렉싱

```text
멀티 스레딩 방식: 손님 1명마다 전담 웨이터 1명 담당 -> 손님이 1000명이면 웨이터도 1000명

I/O 멀티플렉싱: 1명의 웨이터가 전체 대응 -> 손님이 주문할 준비되었을 때만 벨을 누름(이벤트 발생) -> 웨이터가 벨이 울린 테이블만 찾아가서 처리
```

**커널의 I/O 멀티플렉싱 지원**
- 등록: 서버가 관리하고 싶은 소켓들의 목록을 커널에게 맡긴다
- 관찰(블로킹): 서버 스레드는 등록된 소켓들 중 하나라도 데이터를 보내오면 깨워달라고 요청하고 대기한다 (이 때 cpu 낭비 X)
- 알림 및 처리
  - 클라이언트가 데이터를 보낸다
  - 커널은 서버 스레드를 깨우고 특정 소켓에 데이터가 왔다고 알린다
  - 서버 스레드가 깨어나서 해당 소켓의 데이터만 읽고 처리한다
  - 처리가 끝나면 다시 관찰 단계로 돌아간다

프로세스에서 호출할 수 있는 시스템 콜 종류

|구분|select/poll|epoll(linux), kquque(mac), IOCP(windows, input/output completion port)|
|----|---|---|
|방식|관찰 대상 소켓 리스트 전체를 커널에 복사해서 넘긴다|관찰 대상을 커널에 등록해두고 변화가 생긴 소켓만 리턴받는다|
|복잡도|O(n)|O(1)에 근접|
|특징|모든 소켓을 순회하며 데이터가 왔는지 확인한다|이벤트 기반으로 동작하여 데이터가 온 소켓만 고른다|

I/O 멀티플렉싱을 이용하면 스레드 하나로 수천 개의 연결을 관리하므로 효율적으로 메모리 사용할 수 있다

다만 비동기 처리 로직이 필요하여 멀티 스레드 방식보다 코드가 짜기 어렵다

하나의 스레드가 모든 처리를 하므로 특정 요청 처리에 긴 시간을 쓰면 다른 모든 클라이언트가 대기해야 한다 

-> 처리 시간이 긴 연산 작업만 별도의 워커 스레드 풀에 위임하여 해결할 수 있다


## 리액터 패턴 (이벤트 루프와 핸들러)

리액터 패턴은 동시에 들어오는 여러 종류의 이벤트를 단일 스레드에서 받고, 이를 처리할 수 있는 핸들러에게 디스패치한다

**이벤트 루프(리액터)**

OS(디멀티플렉서)로부터 이벤트 발생했음을 전달받기까지 블로킹된다 (`epoll` 등)

이벤트가 발생하면 이를 큐에서 가져와 핸들러에게 디스패치하거나 콜백 함수를 호출한다

이 때 핸들러에 의해 블로킹되지 않고 바로 다음 이벤트를 처리하거나 다시 이벤트를 받기 위해 블로킹된다

**핸들러**

이벤트 루프와 별도로 분리된 스레드에서 비즈니스 로직을 처리한 뒤 완료되면 이를 이벤트로 알린다
