#### 인덱스
- [자료형](#자료형)
- [변수](#변수)
- [표현식과 문장](#표현식과-문장)
- [`sizeof`](#sizeof)
- [`switch`](#switch)
- [함수: Passing by Value](#함수-passing-by-value)
- [포인터: Passing by Reference](#포인터-passing-by-reference)
- [배열: Syntatic Sugar of Pointers](#배열-syntatic-sugar-of-pointers)
  - [배열과 포인터](#배열과-포인터)
- [문자열: 포인터 변수 또는 배열](#문자열-포인터-변수-또는-배열)
- [구조체](#구조체)
- [`typedef`](#typedef)


## 자료형

### 정수형

`char`
- 1바이트
- `signed char`, `char`: -127~127
- `unsigned char`: 0~255
- 문자 저장용
- 문자열은 `char *` 포인터 변수 또는 배열로 표현됨

`short`
- 2바이트
- `short`, `short int`: -32,767 ~ 32,767
- `unsigned short`: 0 ~ 65,535

`int`
- 최소 2바이트 보장, 4바이트 (32/64비트 시스템)
- `int`: 약 -21억 ~ 21억
- `unsigned int`: 0 ~ 42억 

`long`
- 4 또는 8바이트 (플랫폼에 따라 크기 다름)
- -2³¹ ~ 2³¹-1 (최소)
- `unsigned long`(4 또는 8바이트): 0 ~ 2³²-1 (최소)
- `long long`(8바이트): -2⁶³ ~ 2⁶³-1 (`long long int`와 동일)
- `unsigned long long`(8바이트): 0 ~ 2⁶⁴-1

### 부동소수점형

`float`
- 4바이트
- 정밀도 약 7자리
- 단정밀도
- ±1.2×10⁻³⁸ ~ ±3.4×10³⁸
  
`double`
- 8바이트
- 정밀도 약 15자리
- 배정밀도
- ±2.2×10⁻³⁰⁸ ~ ±1.8×10³⁰⁸

`long double`
- 8~16바이트
- 정밀도 18~33자리 (플랫폼에 따라 다름)
- 확장 정밀도

### 크기 고정 정수형

C 언어 스펙은 각 자료형의 크기를 완전히 고정하지 않고 최소 크기만 보장하기에 시스템마다 서로 다른 크기를 가질 수 있다

이식성이 중요한 코드를 작성해야 되는 경우엔 `stdint.h` 헤더를 통해 크기 고정 정수형을 사용하여 정확한 비트 수를 보장해야 한다

`int8_t`
- 1바이트
- -128 ~ 127
  
`uint8_t`
- 1바이트
- 0 ~ 255

`int16_t`
- 2바이트
- -32,768 ~ 32,767

`uint16_t`
- 2바이트
- 0 ~ 65,535

`int32_t`
- 4바이트
- -2³¹ ~ 2³¹-1

`uint32_t`
- 4바이트
- 0 ~ 2³²-1

`int64_t`
- 8바이트
- -2⁶³ ~ 2⁶³-1

`uint64_t`
- 8바이트
- 0 ~ 2⁶⁴-1

### 기타

`_Bool` (불린형)
- 1바이트
- `false`(0) 또는 `true`(0이 아닌 값)
- `stdbool.h` 헤더 포함 시 `bool`, `true`, `false` 매크로 사용 가능

`void`
- 값을 가지지 않는 타입
- 함수 파라미터 리스트가 없거나 반환 값이 없을 때 사용
- 제네릭 포인터: `void *ptr` (어떤 타입의 포인터든 저장할 수 있음)

포인터
- 변수의 주소를 저장하는 특수 변수
- `int *p`, `char *str`

배열
- 동일 타입의 연속된 요소의 집합
- `int arr[10]`

구조체
- 서로 다른 타입의 멤버 묶음
- `struct point { int x, y };`

유니온(공용체)
- 같은 메모리 위치를 여러 타입으로 공유하는 타입
- `union Data { int i; float f; };`

열거형(enum)
- 명명된 정수 상수의 집합
- `enum Color { RED, GREEN, BLUE };`

함수 타입
- 함수 포인터
- `int (*func_ptr)(int, int)`

`size_t`
- `sizeof` 연산자의 반환 타입으로 플랫폼에 따라 `unsigned int` 또는 `unsigned long long`
- format string `%zu` 지정 필요
- `printf("int: %zu bytes\n", sizeof(int));`


## 변수

메모리: 거대한 바이트 배열

메모리 인덱스: 주소(address), 위치(location), 포인터(pointer)

변수: 메모리에 저장된 데이터를 참조하는 인덱스 (human-readable name)

변수 정의? -> 메모리 특정 주소에 변수의 값이 저장됨 -> 해당 주소를 변수를 통해 참조

**변수 규칙**
- 변수 사용 전 변수 선언 및 자료형 명시
- 한 번 선언되면 런타임에 교체 불가
- 설정한 변수는 스코프를 벗어나기 전까지 유지됨
- 초기화되지 않은 변수에는 0 또는 쓰레기 값이 들어감

**Boolean 자료형**
- C에서 불린은 0이면 "false", 0이 아니면 "true"로 판단함 (e.g., -10 -> true)
- C23부터 `bool` 자료형을 지원한다

```c
#include <stdio.h>
#include <stdbool.h>  // C23에선 생략

int main() {
    // bool은 0이면 false, 0이 아니면 true로 판단한다
    // true는 1로 취급된다
    bool x = true; 

    if (x) {
        printf("x is true!\n");
    }
}
```

**컴마 연산자를 이용한 변수 할당**

```c
// x에 10, y에 20 할당
x = 10, y = 20; // 단일 표현식
x = 10; y = 20; // 이중 표현식
```

```c
// 컴마 연산자를 사용하면 가장 오른쪽의 값이 할당된다
x = (1, 2, 3);
```


## 표현식과 문장

**표현식(expression)**이란 **평가(evaluation)**하면 하나의 값으로 도출되거나 결과가 되는 코드 조각을 말한다

즉, 표현식은 항상 어떤 값을 생산하거나 반환한다 -> 값으로 평가되는 코드는 모두 표현식으로 취급된다

표현식은 문장 안에 들어가거나 다른 표현식의 일부로 들어갈 수도 있다

주로 리터럴, 변수, 연산, 함수 호출, 조건부 표현식이 표현식이 된다

```c
i = i + 3;
i += 3;
y += x > 10? 17: 37;
```

문장은 이와 달리 값을 생산하지 않고 주로 동작을 수행한다

```c
if (x > 10) { // if 문
    // 표현식
}
```


## `sizeof`

`sizeof` 연산자는 특정 변수나 데이터 타입이 메모리에서 차지하는 크기(바이트)를 표시한다

항상 1 바이트를 나타내는 `char` 자료형을 제외하고 다른 자료형은 시스템에 따라 다르게 나타날 수 있다

C 언어는 `sizeof` 함수의 반환 값을 나타내는 `size_t` 라고 하는 특별한 타입을 가진다

`size_t`는 `sizeof` 함수에 전달하는 모든 데이터의 크기를 바이트 단위로 저장할 수 있는 부호없는 정수형이다 (unsigned integer)

-> sizeof에 전달한 표현식의 값이 아닌, 타입에 대한 바이트의 크기를 나타낸다는 것에 주의하자


## `switch`

`switch`의 조건식에 들어갈 수 있는 값은 정수 자료형만 허용한다

조건에 맞는 `case`로 이동한 뒤 실행을 계속 이어나가며, `break`문을 만나면 `switch` 바깥으로 벗어난다

`fall through`: `case`문에 `break`를 명시하지 않아 다른 `case`문까지 실행을 계속 이어나가는 현상

```c
#include <stdio.h>

int main() {

    int x = 1;

    // case 1에 break문이 없어 case 2까지 실행된다
    switch (x) {
        case 1:
            printf("1\n");
            // Fall through!
        case 2:
            printf("2\n");
            break;
        case 3:
            printf("3\n");
            break;
    }
}
```

C에서 `char`는 정수값으로 치환될 수 있기 때문에 `switch` 조건식에서 사용할 수 있다 (`enum`도 가능)

```c
#include <stdio.h>

int main() {
    char c = 'b';

    switch (c) {
        case 'a':
            printf("It's 'a'!\n");
            break;

        case 'b':
            printf("It's 'b'!\n");
            break;

        case 'c':
            printf("It's 'c'!\n");
            break;
    }
}
```


## 함수: Passing by Value

```c
// int: 반환 타입
// plus_one: 함수명
// int n: 인자, 파라미터 'n'에 저장됨
int plus_one(int n) {
    return n + 1;
}
```

파라미터는 호출자가 전한 인자의 값을 **"복사한"** 지역 변수다

정확히는 인자가 변수인 경우 인자 표현식을 평가하여 값이 정해진 상태에서 그 값을 복사하여 파라미터에 저장한다

이를 **`Passing by Value`(값에 의한 전달)** 라고 한다

파라미터는 자기 자신의 값을 가지는 것이며 호출자가 전달한 인자의 값로부터 완전히 독립된다 -> 파라미터와 인자는 서로 다른 값을 가진다 (인자가 변수인 경우)

```c
#include <stdio.h>

// function prototype
// 함수를 선언하지 않으면 컴파일러가 이를 미리(ahead-of-time) 알지 못하며, 함수를 호출하는 코드를 컴파일할 때 오류가 발생한다
void plus_one(int); 

int main() {

    int i = 10;

    // value of the i before plus_one(i): 10
    // value of the parameter n in the plus_one(int):: 11
    // value of the i before plus_one(i): 10
    printf("value of the i before plus_one(i): %d\n", i);

    plus_one(i);

    printf("value of the i after plus_one(i): %d\n", i);
}

void plus_one(int n) {
    n = n + 1;
    printf("value of the parameter n in the plus_one(int): %d\n", n);
}
```

### void 파라미터 리스트

**어떠한 파라미터도 받지 않는 함수를 선언/정의하는 경우엔 파라미터에 `void`를 명시해야 한다**

```c
int func(void);  // 선언
int func(void) { // 정의
    return 42;
}

int func();    // 구식 선언
int func() {   // 구식 정의
    return 42;
}
```

C 언어는 하나의 `return` 문에서 여러 값을 직접 반환할 수 없다 (튜플 반환)

-> 함수가 반환할 수 있는 값은 언제나 한 개뿐이다

다중 값을 반환하려면 포인터나 구조체를 사용해야 한다


## 포인터: Passing by Reference

포인터는 메모리의 주소값을 가지고 있는 변수다

변수가 메모리의 특정 주소에 저장된 값을 가리킨다면, 포인터는 메모리의 특정 주소에 저장된 다른 특정 주소 값을 가리킨다

```text
                 메모리
변수           주소     값
i ---------> 0x1000   10
                ^
                |              
                ------------- |  
                              |
포인터 변수      주소     값       |
p ---------> 0x2000  0x1000 ---
```

```c
int i = 10;  // 변수
int *p;      // int 포인터 변수

p = &i;      // 참조 (i의 주소를 p에 할당)
*p = 20;     // 역참조 (p를 통해 i에 접근 후 값을 20으로 수정)
```

함수의 호출자가 전달한 인자는 "표현식을 평가하여 결정된 값"을 파라미터에 복사하여 전달된다

인자가 포인터 변수라면 포인터의 값, 즉 포인터 변수가 참조하고 있는 메모리 주소를 파라미터에 복사한다 (파라미터도 주소를 참조해야 하므로 포인터 변수여야 함)

결과적으로 파라미터와 인자가 모두 같은 값을(참조하는 주소 값) 가지게 되며, 함수 안에서 파라미터 포인터 변수를 통해 역참조하여 원본 변수의 값을 변경하면 함수 바깥 스코프에도 영향을 끼치게 된다

이를 **`Passing by Reference`(주소에 의한 전달)** 라고 한다

```text
                      메모리
변수                 주소     값
i -------------->  0x1000   10
                     ^
                     |              
                     --------------|---| 
                                   |   |
포인터 변수(인자)      주소     값       |   |
p --------------> 0x2000  0x1000 ---   |
                            |          |
                            | copy     |
                            |          |
                            V        |--
포인터 변수(파라미터)    주소     값        |
p ---------------> 0x3000  0x1000 ----
```

```c
#include <stdio.h>

void plus_one(int*); 

int main(void) {

    int i = 10;
    int *j = &i;

    // value of the i before plus_one(j): 10
    // value of the parameter n in the plus_one(int*):: 11
    // value of the i before plus_one(j): 11
    printf("value of the j before plus_one(j): %d\n", *j);

    plus_one(j);

    printf("value of the i after plus_one(i): %d\n", *j);
}

void plus_one(int* n) {
    *n = *n + 1;
    printf("value of the parameter n in the plus_one(int*): %d\n", *n);
}
```

### NULL 포인터

포인터 변수가 아직 어떤 것도 참조하지 않을 때 포인터 타입과 관계없이 `NULL`을 할당할 수 있다

```c
int *p;
p = NULL;
```

### 포인터 변수와 변수 선언

같은 자료형을 가진 변수를 하나의 라인으로 선언하듯이, 아래와 같이 동일한 자료형에 대한 포인터 변수와 일반 변수를 함께 선언할 수 있다

```c
// int 변수 a, b 선언
int a, b;

// int 변수 a, int 포인터 변수 p 선언
int a, *p; 
int *p, a;
int* p, a;
```

### 포인터 변수에 대한 sizeof 연산

```c
int *p;

// Prints size of an 'int'
printf("%zu\n", sizeof(int));

// p is type 'int *', so prints size of 'int*'
printf("%zu\n", sizeof p);

// *p is type 'int', so prints size of 'int'
printf("%zu\n", sizeof *p);
```


## 배열: Syntatic Sugar of Pointers

**배열 선언 및 초기화**

```c
// 20 int 배열 선언
// 0부터 인덱싱 시작
int a[20];  

// 배열 선언 및 초기화
// 더 많은 요소를 초기화하면 컴파일 에러 발생
int b[5] = {10, 20, 30, 40, 50}; 

// 초기화 시 사이즈보다 더 적은 요소로 초기화할 수 있다
// 남은 요소는 0으로 초기화된다
int c[5] = {10, 20, 30}; 

// 모든 요소를 0으로 초기화
int d[100] = {0};

// 특정 인덱스를 지정하여 초기화할 수 있다
// 인덱싱 뒤의 초기화 값들은 해당 인덱스 이후의 위치에서 초기화된다
// 0 11 22 0 0 55 66 77 0 0
int e[10] = {0, 11, 22, [5]=55, 66, 77};

// 간단한 표현식도 사용할 수 있다
// 0 0 3 2 1
#define COUNT 5
int f[COUNT] = {[COUNT-3]=3, 2, 1};

// C가 배열의 사이즈를 계산하도록 할 수 있다
int g[] = {10, 20, 30, 40};
```

**배열 사이즈 구하기**

```c
int a[20];

sizeof(int)            // 4 바이트
sizeof a               // 80 바이트 (int * 20)
sizeof a / sizeof(int) // 80/4 = 20 ints
sizeof(int [20]);      // 80 바이트
```

**배열 인덱싱 주의사항**

C에서 배열의 사이즈를 넘어서 인덱싱을 하면 0 또는 쓰레기 값을 찾거나 충돌 등 정의하지 않은 행동(`undefined behavior`)이 발생한다 

실제로 C 스펙에서 컴파일러는 이런 상황에서 무엇이든 할 수 있다고 명시되어 있으며 개발자는 정의하지 않은 행동이 발생하지 않도록 주의해야 한다

```c
#include <stdio.h>

int main(void)
{
    int i;
    int a[5] = {22, 37, 3490, 18, 95};

    for (i = 0; i < 10; i++) {  // BAD NEWS: printing too many elements!
        printf("%d\n", a[i]);
    }
}
```

### 배열과 포인터

배열의 변수는 첫 번째 인덱스를 가리키는 포인터 변수이다

```c
#include <stdio.h>

int main() {

    // a는 a[0]에 대한 포인터 변수
    // a[0]은 *a(역참조)와 동일
    int a[5] = {1, 2, 3, 4, 5};
    int *p;

    p = a; // p = &a[0];와 동일

    printf("address of the a: %p\n", a); 
    printf("address of the p: %p\n", p); // a, p의 참조값은 동일하다

    printf("value of the *a: %d\n", *a);     // 1
    printf("value of the a[0]: %d\n", a[0]); // 1   
    printf("value of the *p: %d\n", *p);     // 1
}
```

**함수에 일차원 배열 전달**

times2/3/4에서 배열을 받을 때 선언한 `int *a`, `int a[]`, `int a[5]`는 모두 동일하다

**배열에 대한 참조값을 전달받기 때문에 함수에서 배열을 수정하면 바깥까지 영향을 주게 된다**

```c
#include <stdio.h>

// Passing as a pointer to the first element
void times2(int *a, int len)
{
    printf("------times2------\n");
    for (int i = 0; i < len; i++)
        printf("%d\n", a[i] * 2);
}

// Same thing, but using array notation
void times3(int a[], int len)
{
    printf("------times3-------\n");
    for (int i = 0; i < len; i++)
        printf("%d\n", a[i] * 3);
}

// Same thing, but using array notation with size
void times4(int a[5], int len)
{
    printf("------times4-----\n");
    for (int i = 0; i < len; i++)
        printf("%d\n", a[i] * 4);
}

int main(void)
{
    printf("-----original------\n");
    int x[5] = {11, 22, 33, 44, 55};

    for (int i = 0; i < 5; i++)
        printf("%d\n", x[i]);

    times2(x, 5);
    times3(x, 5);
    times4(x, 5);
}
```

```text
-----original------
11
22
33
44
55
------times2------
22
44
66
88
110
------times3-------
33
66
99
132
165
------times4-----
44
88
132
176
220
```

**함수에 다차원 배열 전달**

다차원 배열을 함수에 전달할 때는 첫 번째 차원을 제외한 나머지 차원을 명확히 명시해야 한다

```c
// 첫 번째 차원은 생략할 수 있다
void print_2D_array(int a[2][3])
void print_2D_array(int a[][3])
```


## 문자열: 포인터 변수 또는 배열

C에서 문자열 리터럴은 무조건 쌍따옴표로 표시된다 (홑따옴표는 `char` 문자 리터럴을 나타낼 때만 사용)

```c
"Hello, world!\n"
"This is a test."
"When asked if this string had quotes in it, she replied, \"It does.\"" 
```

문자열은 `char` 포인터 변수를 통해 참조할 수 있다

배열과 마찬가지로 가장 첫 번째 문자의 주소를 참조한다

그리고 문자열의 맨 끝에 문자가 끝나는 것을 C에게 알려주는 값(zero-valued 바이트 또는 NULL 문자)이 포함된다

```c
char *s = "Hello, world"; // 실제론 "Hello, World\n"임

printf("%s\n", s); // Hello, world

// Hello, World
for (int i = 0; i < 13; i++)
    printf("%c", s[i]);
printf("\n");
```

또는 `char` 배열 그 자체로 선언할 수도 있다

```c
char s[] = "Hello, world";

// Hello, World
for (int i = 0; i < 13; i++)
    printf("%c", s[i]);
printf("\n");
```

### `char` 포인터 변수와 `char` 배열의 차이

문자열을 포인터 변수나 배열로 선언하든 출력은 동일하다

다만 저장 위치와 문자열 리터럴 수정 여부, 포인터 수정 여부, 크기, 메모리 소유권에 있어서 차이가 있다

|구분|`char *str = "hello`|`char str[] = "hello"`|
|---|----|---|
|저장 위치|문자열 리터럴이 읽기 전용 메모리에 저장된다|문자열 리터럴이 배열의 초기화 값으로 사용되어 배열 내용이 스택(지역) 또는 데이터 영역(전역)에 복사된다|
|문자열 리터럴 수정 여부|불가능, 수정 시 undefined behavior (세그멘테이션 폴트 발생 가능)|가능, `str[0] = "H";`|
|포인터 자체 수정 여부|가능, `str = "world";`로 다른 문자열 가리키게 할 수 있다 |불가능, `str = "world";` 시 컴파일 에러 발생|
|크기|`sizeof(str)` = 포인터 크기 8바이트|`sizeof(str)` = 배열 크기|
|메모리 소유권|포인터는 문자열 리터럴을 가리킬 뿐 소유하지 않는다|배열이 실제로 문자를 복사해서 가지고 있다|


### 문자열 길이 구하기

`string.h` 헤더 파일의 `strlen` 함수를 통해 문자열의 길이를 계산할 수 있다

`strlen` 함수는 `size_t` 타입을 반환한다

```c
#include <stdio.h>
#include <string.h>

int main(void) {

    char *s = "Hello, world";

    printf("%zu\n", strlen(s));
    return 0;
}
```

### 문자열 복사

할당 연산자 `=`를 이용하면 첫 문자의 주소를 복사할 뿐이다

문자열을 복사하려면 각 문자 바이트를 일일이 메모리의 다른 곳에 복사해야 한다

C 언어에선 복사될 공간을 만들어 놓고 `strcpy` 함수를 사용하여 해당 메모리에 복사시킬 수 있다 (복사할만큼 충분한 공간 확보 필요)

```c
#include <stdio.h>
#include <string.h>

int main(void) {
    
    char src[] = "Hello, world";
    char dest[100];

    strcpy(dest, src);

    dest[0] = 'z';

    printf("%s\n", src);  // "Hello, world"
    printf("%s\n", dest); // "zello, world"

    return 0;
}
```


## 구조체

다양한 데이터와 자료형을 가진 사용자 정의 타입을 구조체라고 한다

OOP의 클래스에서 메서드를 빼고 필드만 있는 느낌

```c
// 타입 이름: struct car (car이 아님)
struct car {
    char *name;
    float price;
    int speed;
};
```

```c
// 변수 modelY의 타입: "struct car"
// 초기화되지 않은 상태 (zero 값으로 초기화됨)
// <변수>.<필드>로 필드에 접근할 수 있다
struct car model_y;
model_y.name = "Saturn SL/2";
model_y.price = 15999.99;
model_y.speed = 175;

// struct car를 참조하는 포인터 변수
// <포인터 변수>-><필드>로 필드에 접근할 수 있다
struct car *model_y;
model_y->name = "Saturn SL/2";
model_y->price = 15999.99;
model_y->speed = 175;

// 또는 역참조하여 .를 통해 접근할 수 있다
(*model_y).name = "Saturn SL/2";
```

```c
// 구조체 정의와 동일한 필드 순서로 값을 할당하여 구조체 변수 선언 및 초기화를 한 번에 할 수 있다
struct car model_y = {"Saturn SL/2", 16000.99, 175};

// 초기화 시 특정 필드를 지정할 수도 있다
struct car model_y = {.speed=175, .name="Saturn SL/2"};
```

**구조체를 비교하는 가장 안전한 방법은 오직 각 필드를 일일이 비교하는 방법밖에 없다**

### 함수에 구조체 전달

함수에 구조체 자체 또는 구조체에 대한 포인터를 전달할 수 있다

포인터를 전달하는 경우 (좀 더 일반적임)
- 함수에서 호출자가 전달한 구조체를 변경하고 싶은 경우
- 구조체를 함수의 스택에 복사하기에 크기가 너무 큰 경우

```c
#include <stdio.h>

struct car {
    char *name;
    float price;
    int speed;
};

void set_price(struct car *, float);

int main(void) {
    struct car model_y = {.speed=175, .name="Saturn SL/2"};

    set_price(&model_y, 799.99);
    
    printf("Price: %f\n", model_y.price);
    return 0;
}

void set_price(struct car *c, float price) {
    c->price = price;
}
```

### 구조체 복사 또는 반환

문자열과 달리 구조체는 할당 연산자(`=`)를 사용해서 복사할 수 있다

또한 함수에서 구조체를 반환하는 경우에도 구조체의 값이 복사된다

다만 얕은 복사이기 때문에 모든 변수가 완전히 복사되지 않는다는 것에 유의하자

```c
#include <stdio.h>

struct car {
    int speed;
};

int main(void) {

    struct car model_s, model_y;

    model_s.speed = 100;
    
    // shallow copy
    model_y = model_s;
    model_y.speed = 150;

    printf("model_s speed is %d\n", model_s.speed); // 100
    printf("model_y speed is %d\n", model_y.speed); // 150

    return 0;
}
```


## `typedef`

`typedef` 예약어를 통해 기본 자료형에 별칭을 더한 새로운 자료형을 만들 수 있다

```c
typedef int response_code;      // int 별칭 "repsonse_code" 정의

response_code not_found = 404;  // response_code는 int와 동일한 타입이다
```

```c
// 구조체 이름: struct animal
// typedef struct animal animal: struct animal 타입을 animal로 별칭
typedef struct animal {
    char *name;
    int leg_count, speed;
} animal;

animal lion;


// typedef 별칭 지정 시 구조체 이름을 생략할 수 있다
typedef struct {
    int x, y;
} point;

point p = {.x=20, .y=40};
```

