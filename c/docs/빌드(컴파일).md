#### 인덱스
- [C 프로그램 빌드: 소스 파일을 실행 가능한 파일로 만드는 과정](#c-프로그램-빌드-소스-파일을-실행-가능한-파일로-만드는-과정)
- [1. 전처리기: 소스 파일 -\> `.tu` 파일](#1-전처리기-소스-파일---tu-파일)
- [2. 컴파일러: .tu 파일 -\> -o 파일](#2-컴파일러-tu-파일----o-파일)
- [3. 링커: 모든 `.o` 파일, 라이브러리 머지 -\> 실행 파일/공유 라이브러리/정적 라이브러리](#3-링커-모든-o-파일-라이브러리-머지---실행-파일공유-라이브러리정적-라이브러리)
- [4. 로더: 실행 파일 -\> 프로세스](#4-로더-실행-파일---프로세스)
- [컴파일러 드라이버 종류](#컴파일러-드라이버-종류)
- [GNU](#gnu)


## C 프로그램 빌드: 소스 파일을 실행 가능한 파일로 만드는 과정 

C 언어, 오브젝트 파일, 어셈블리어, 기계어

소스 파일을 실행 가능한 파일로 만드는 컴파일러는 정확히 **"컴파일러 드라이버"**이며 컴파일러 이외에 전처리기, 링커, 로더라고 하는 개별적인 CLI 파일을 포함한다

**컴파일러 드라이버**: 전처리기(cpp), 컴파일러(cc), 링커(ld), 로더(loader) 

<img src="./images/build-process.svg" alt="build process" style="">

## 1. 전처리기: 소스 파일 -> `.tu` 파일

전처리기, preprocessor 또는 cpp (C PreProcessor)

전처리기는 `#`를 접두사로 갖는 코드(Directive)를 대상으로 아래의 전처리 작업을 수행하고 결과물로 Translation Unit(`.tu`)을 출력한다 (`.tu` 파일은 다음 단계에서 컴파일러에 의해 처리된다)
- 의존성 해결 (헤더 파일의 declaration 포함)
- 매크로 선언
- 조건부 컴파일 수행

참고로 전처리기는 소스 파일의 확장자가 무엇이든, 심지어 문자열 파일조차 `#` 캐릭터로 시작하는 명령어가 있으면 전처리 작업을 수행할 수 있다

#### 예시

```c
// 소스 파일
// hello.c
#include "stdio.h"
#include "stdlib.h"

int main()
{
    printf("Hello World\n");
    return 0;
}
```

```text
// 전처리를 거친 .tu 파일

<stdio.h 내용>
<stdlib.h 내용>

foo.c 본문
```

cpp(C PreProcessor)를 이용하여 전처리기가 생성한 `.tu` 파일을 직접 확인할 수도 있다

```shell
cpp -v hello.c -o hello.tu
```

전처리기에 의해 생성된 `.tu` 파일에는 해당 파일에서 사용하는 의존성, 매크로 등이 모두 선언되어 있다

```shell
wc -l hello.c
       7 hello.c
```

```shell
cpp hello.c > hello.tu
wc -l hello.tu
    9151 hello.tu
```

Translation Unit 파일의 내부를 잠깐 살펴보면 각 코드마다 `# linenum filename flags` 형태의 주석이 먼저 달린다

이 주석은 해당 코드가 어디에서 왔는지 추적할 수 있게 해준다

```text
# 82 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_stdio.h" 2 3

int  printf(__const char * restrict, ...) __attribute__((__format__ (__printf__, 1,  2)))

# 2 "hello.c" 2

int main()
{
    printf("Hello World");
    return 0;
}
```

또한 전처리기는 커맨드라인 파라미터 `-D` 플래그를 통해 특정 값을 정의할 수도 있다

```c
// defined_return_code.c

int main()
{
    return RETURN_VALUE;
}
```

```c
clang -DRETURN_VALUE=3 defined_return_code.c
./a.out ; echo $ ?
3
```

### 헤더 파일

C 언어가 만들어질 70년대에는 메모리가 굉장히 제한되서 컴파일러가 소스 전체를 메모리에 올려두고 여러 번 분석할 수 없었다

그래서 소스를 앞에서부터 한 줄씩 읽고 즉시 의미 분석한 뒤 명령어를 생성했다

-> 컴파일 단위 = 소스 파일 1개

이러한 구조로 인해 C는 함수나 변수를 사용하기 전에 **먼저 선언(Declaration)**하도록 강제하여 함수를 만나기 전에 타입 정보를 알아둔다

정의(Definition)는 선언한 후에 온다

```c
int mul(int x, int y);  // 선언
int mul(int x, int y) { // 정의
    return x * y;
}

extern int i;           // 선언
int i = 0;              // 선언 및 정의
```

만약 파일 간 서로 특정 코드를 의존하거나, 공통적으로 사용하는 코드가 있다면 이를 헤더 파일에 선언해두고 소스 코드(헤더와 같은 이름의 `.c` 파일)에 정의해두면 된다

헤더 파일이 다른 헤더 파일을 포함할 수도 있다

```c
// int foo.h
// mul과 sub 함수를 선언한다

int mul(int x, int y);
int sub(int x, int y);
```

```c
// int foo.c
// foo.h에 선언한 함수를 정의한다

#include "foo.h"

int mul(int x, int y)
{
    return x * y;
}

int sub(int x, int y)
{
    return x - y;
}
```

```c
// bar.c
// foo.h 헤더 파일을 참조하여 함수를 사용한다

#include "foo.h"

int div(int x, y) {
    int c = x;
    while(y--)
        x = sub(x, 1);
    return c; 
}
```

`bar.c`의 tu 파일을 확인해보면 `foo.h`에 정의된 함수를 사용하기 전에 선언된 것을 확인할 수 있다

```shell
cpp bar.c > bar.tu
```

```text
# 1 "bar.c" 2
# 1 "./bar.h" 1
int div(int x, int y);
int add(int x, int y);

# 2 "bar.c" 2
# 1 "./foo.h" 1
int mul(int x, int y);
int sub(int x, int y);

# 3 "bar.c" 2

int div(int x, int y)
{
    int c = x;
    while(y--)
        x = sub(x, 1);
    return c;
}

int add(int x, int y)
{
    return x + y;
}
```

### 매크로를 사용하는 이유: include guard, pragma guard

만약 헤더 파일이 간접/중첩적으로 포함되면 TU에 여러 번 함수/변수가 중복적으로 선언되어 컴파일이 제대로 진행되지 않는다

```c
// engine.h
struct World {
}; 
```

```c
// engine.cc
// render.h와 ai.h 헤더 파일을 포함한다
// 이 파일들은 다시 engine.h 파일을 포함한다
#include "engine.h"
#include "render.h"
#include "ai.h"

void hostFrame(World& world) {
  think(world);
  render(world);
}
```

```c
// ai.h
#include "engine.h"

void think(World& world);
```

```c
// ai.cc
#include "ai.h"

void think(World& world) {}
```

```c
// render.h
#include "engine.h"

void render(World& world);
```

```c
// render.cc
#include "render.h"

void render(World &worldv) {}
```

이제 `engine.cc`의 `.tu` 파일을 살펴보면 `World` 구조체가 3번 선언된 것을 확인할 수 있다

```shell
cpp engine.cc
```

```c
// engine.h에서 선언
struct World {
}; 

// engine.h를 포함한 render.h에서 선언
// engine.h는 render.h를 포함한다
struct World {
}; 

void render(World& world);

// engine.h를 포함한 ai.h에서 선언
// engine.h는 ai.h를 포함한다
struct World {
}; 

void think(World& world);


void hostFrame(World& world) {
  think(world);
  render(world);
}
```

이렇게 Translation Unit을 만드는 과정에서 함수/변수가 중복적으로 선언되지 않도록 전처리기에 지시하기 위해 인클루드 가드 또는 `pragma` 가드를 사용한다

이 가드는 전처리 단계에서 같은 헤더 파일이 한 TU에 여러 번 선언되는 것을 막는다

전처리기는 파일을 읽으면서 내부에 **매크로 심볼 테이블**이라고 하는 전역 상태를 유지한다

여기에 `#define`으로 정의된 모든 매크로 이름이 저장되어 있다

파일을 처음 include 했을 때는 매크로가 테이블에 없으므로 조건이 참으로 평가되어 이후 지시어를 처리한다

두 번째 include를 하면 이미 정의된 매크로가 테이블에 있으므로 조건이 거짓되어 `#endif`까지 모두 무시한다

```c
// engine.h
// pragma는 TU에서 한 번만 포함하라는 지시어이다
// C 표준은 아니지만 대부분 지원한다

// engine.cc -> engine.h
// engine.cc -> ai.h -> engine.h
// engine.cc -> render.h -> engine.h
// engine.cc에서 engine.h, ai.h, render.h 파일을 포함하여 총 3번 호출되지만 pragma 지시어로 인해 단 한번만 World 구조체가 포함된다
#pragma once

struct World{};
```

```c
// ai.h
#ifndef AI.H  // Header guard
#define AI.H
#include "engine.h"

void think(World& world);

#endif // AI.H
```

```c
// render.h
#ifndef RENDERER.H // Header guard
#define RENDERER.H
#include "engine.h"

void render(World& world);

#endif // RENDERER.H
```

```c
// header guard를 이용하여 World 구조체를 단 한번만 선언한다
// engine.tu
# 1 "engine.cc" 2
# 1 "./engine.h" 1

struct World{};

# 2 "engine.cc" 2
# 1 "./render.h" 1

void render(World& world);

# 3 "engine.cc" 2
# 1 "./ai.h" 1

void think(World& world);

# 4 "engine.cc" 2

void hostFrame(World& world)
{
    think(world);
    render(world);
}
```

### Precompiled Headers (PCH)

전처리기를 통해 처리된 각 소스 파일의 `#include` 지시어의 출력값은 파일의 크기가 클수록 커진다

빌드 시간을 줄이기 위해 미리 컴파일된 헤더(Precompiled Headers, PCH)를 사용할 수 있다

PCH는 헤더 파일을 `.o` 파일로 컴파일하는 게 아니라 전처리 및 파싱이 끝난 컴파일러 내부 상태를 직렬화한 스냅샷이다

**일반 컴파일 과정**

```text
.c or .cpp
   ↓
전처리 (include, macro)
   ↓
파싱 (AST 생성)
   ↓
의미 분석
   ↓
IR 생성
   ↓
코드 생성
```

**PCH 사용 시**

PCH 생성

```text
header 집합
  ↓
전처리
  ↓
파싱 + 의미 분석
  ↓
[컴파일러 내부 상태 저장]  ← PCH
```

컴파일

```text
PCH 로드
   ↓
컴파일러 상태 복원
   ↓
남은 소스 파싱
   ↓
IR 생성
   ↓
코드 생성
```

중복되는 헤더 파일을 PCH로 만들면 각 소스 파일에 대한 TU 파일의 크기를 줄일 수 있다

```code
// all_header.h

#include "engine.h"
#include "ai.h"
#include "render.h"
```

engine.cc, ai.cc, render.cc의 `#include` 지시어를 모두 삭제한다

```shell
// PCH 생성
clang++ -x c++-header all_header.h -o all_header.pch

// 컴파일러 드라이버에게 PCH 전달
// 각 소스 파일은 PCH를 통해 컴파일된다
clang++ -include-pch all_header.pch -c render.cc ai.cc engine.c
```

### 헤더 파일 검색 경로

전처리기는 `#include` 지시어에 포함된 경로를 해당 소스 파일이 위치한 디렉토리에서 찾는다

표준 라이브러리 헤더(시스템 헤더)나 컴파일러 자체가 내부적으로 제공하는 헤더(`stddef.h` 등)의 경우 전처리기가 자동으로 찾는다

외부 라이브러리 헤더같이 전처리기가 자동으로 찾지 못하는 헤더들은 헤더 검색 경로를 이용하여 찾으려고 시도한다

헤더 파일 경로 지정 플래그
- `-I`
- `-sysroot`
- `-iquote`
- `-isystem`


## 2. 컴파일러: .tu 파일 -> -o 파일

전처리기의 Translation Unit 변환 단계는 `#` 접두사를 이용하여 의존성 선언, 매크로 정의, 조건부 컴파일을 명시한 것을 실현하기 위해 필요한 내용들을 해당 소스 코드의 파일에 추가한 것이다

컴파일러 파이프라인은 전처리기에 의해 생성된 TU들을 기반으로 오브젝트 파일로 변환한다

CPU는 단 3가지만 알고 있다
- 명령어(opcode)
- 레지스터
- 메모리 주소

함수, 변수, 파일, 심볼 이름 등은 전혀 알지 못한다

그리고 다음과 같이 동작한다

```text
PC(Program Counter)가 가리키는 주소에서 명령어를 가져온다
레지스터/메모리를 읽고 쓴다
PC를 갱신한다
```

즉, CPU 관점에서 코드는 그저 특정 **메모리 주소**에 저장된 명령어일 뿐이다

```text
ldr x0, [0x7ffeedc0]
bl  0x400580

0x7ffeedc0: 메모리 주소
0x400580: 점프할 주소
```

프로그래밍 언어에는 변수, 함수, 스코프, 타입이 있지만 **CPU는 레지스터 위치, 메모리 주소의 위치, 다음 명령어 주소만 알고 있다**

그래서 **컴파일러**는 **모든 추상 개념**을 **명령어와 주소 참조로 분해**해야 한다

주소 참조는 프로그램이 동작하게 하기 위해 컴파일러가 특정 CPU에 맞게 번역한 명령어, 데이터가 메모리의 어디에 어떻게 위치해야되는지를 지정하는 것이다

하지만 컴파일 시점에는 다음과 같은 이유로 메모리의 어느 주소를 언제, 어떤 순서로 지정해야 될지 알 수 없다
- 컴파일러는 단일 TU만 볼 수 있는데, 단일 TU는 전체 메모리 레이아웃을 모른다
- 주소를 지정하면 오브젝트 파일을 재사용할 수 없다
- 런타임에 메모리 주소가 바뀔 수 있다

따라서 컴파일러는 **relocation** 이라는 기술을 사용하여 주소 결정을 런타임(프로세스가 실행되는 시점)으로 미룬다

relocation은 **코드 결합을 가능하게 하는 공식 규약**으로 여러 개의 독립적으로 컴파일된 코드 조각을 하나의 실행 가능한 메모리 이미지로 합치기 위한 기술이다

relocation 덕분에 다음과 같은 것들이 가능해진다
- 분리 컴파일 (`.c` -> `.o` -> 링크)
- 라이브러리 생태계 (`.a`, `.so`)
- 동적 링크 (런타임에 함수 연결)
- 위치 독립 코드(PIC, 같은 코드 페이지를 여러 프로세스가 공유)
- 보안(ASLR, PIE)

결론적으로 컴파일러 파이프라인은 TU를 파싱하여 특정 CPU 명령어로 변환하고, 변환된 각 코드 조각(TU별)들을 하나의 실행 가능한 파일로 만들 수 있도록 relocation된 오브젝트 파일들을 만든다

오브젝트 파일은 실행되는 파일이 아니고 메모리의 주소가 재지정될 수 있기 때문에 Relocatable File이라고 한다

### 컴파일러 파이프라인

주요 역할: TU 파싱/의미 분석 -> IR 변환 -> IR 최적화 -> 타겟 머신 코드 생성 -> 오브젝트 파일 생성(relocatable)
- **TU 파싱**: 문법 검증, 타입 검사, 스코프 해석 등 기계어로 바꾸기 전 올바른 의미를 가지는지 확인한다
- **IR 생성**: 언어와 타겟(CPU)을 분리하기 위한 목적
- **IR 최적화**: 불필요한 연산 제거, 레지스터 활용 개선, 루프 변환
- **타겟 머신 코드 생성**: IR 연산 -> CPU 명령어 선택, 레지스터 할당 및 명령어 스케줄링 (순수 명령어 시퀀스, 파일 X, 주소 미정)
- **오브젝트 파일 생성 (어셈블러)**: 섹션 구성, 심볼 테이블 생성, relocation 기록, 파일 포맷 인코딩 등 링커를 위한 정보로 구성된 파일을 생성한다

모든 컴파일러는 아래와 같은 구조를 가진다
- 텍스트를 IR(Intermediate Representation)으로 변환하는 프론트엔드
- 최적화 작업을 수행하는 옵티마이저
- 해당 머신에 적합한 기계어를 생성하는 백엔드 (gcc는 어셈블리를 만들고 `binutils`의 `as`를 통해 기계어로 변환한다)

컴파일러를 거쳐 나온 기계어는 오브젝트 파일 형식 컨테이너에 패키징된다

<img src="./images/compiler_structure.svg" alt="compiler structure" style="">

Clang은 **C/C++의 IR을 생성하는 프론트엔드**이고 LLVM 백엔드를 이용해 특정 아키텍처에 적합한 어셈블리/바이너리로 변환한다 (clang은 LLVM 기반 컴파일러 파이프라인을 제어하는 CLI 도구임)

<img src="./images/llvm_compiler.svg" alt="llvm compiler" style="">

```text
텍스트 소스(Translation Unit)
     ↓
Clang 프론트엔드: LLVM IR 생성 (target-independent)
     ↓
LLVM Optimizer: LLVM IR 최적화
     ↓
LLVM Backend
     ↓
Machine Code: (specific target architecture, 어셈블리 또는 바이너리)
     ↓
Assembler     
     ↓
Relocatable Object(.o)
```

### 오브젝트 파일 인코딩 포맷

오브젝트 파일은 CPU나 OS 별로 인코딩 포맷이 다르다

TU를 파싱하여 특정 CPU가 인식할 수 있는 명령으로 변환하기 때문에 시스템에서 사용 중인 CPU 종류와 OS 로더/링커 계약에 종속된다

CPU 명령어 종류
- x86-64: 가변 길이
- ARM64: 고정 길이

OS에 따른 오브젝트 포맷
- Linux: ELF
- MacOS: Mach-O
- Windows: COFF/PE

동일 OS/다른 CPU 명령어
- x86-64: ELF x86-64
- ARM64: ELF AArch64
- RISC-V: ELF RISC-V

### 오브젝트 파일이 포함하고 있는 정보

오브젝트 파일이 포함한 정보는 링커에 의해 소비된다
- CPU 명령어(기계어): 실행될 코드
- 섹션 정보: 코드와 데이터 분리
- 심볼 테이블: 이름과 주소 위치 변환
- relocation: 미지정된 주소의 수정되어야 할 지점

기타 정보
- 레지스터 규약
- 호출 규약(ABI)
- relocation 타입
- 심볼 해석 규칙
- 로더가 이해할 메타데이터

### ELF

ELF 파일은 오브젝트 파일에 포함되는 정보들을 섹션 단위로 나눈다

섹션: 링커를 위한 논리적 구성

세그먼트: 로더를 위한 메모리 배치 단위

```text
ELF
├─ .text: CPU 명령어가 들어간 섹션(소스 코드), CPU가 실제로 실행하는 유일한 섹션
├─ .rodata: 읽기 전용 데이터, 문자열 리터럴 또는 const 전역 데이터
├─ .data: 초기값 있는 전역/정적 변수
├─ .bss: 초기값 없는 전역/정적 변수
├─ .symtab / .dynsym: 함수, 변수 이름을 주소 위치로 매핑하는 심볼 테이블(symtab: 정적 링킹용, dynsym: 동적 링킹용)
├─ .rela.text / .rela.data: relocation 섹션
├─ .strtab: 문자열 테이블
```

mac에서 리눅스 ELF 오브젝트 파일 생성

```c
// mult.c
int mul(int x, int y);

int pow(int x) { 
    return mul(x, x) ; 
}
```

```shell
clang --target=aarch64-linux-gnu -c mult.c -o mult.o

# GNU binutils 설치
# 환경변수 PATH 설정 필요
$ brew install binutils
```

각 섹션 헤더 중`.text`(Name) 헤더가 함수의 명령(instruction)이 저장되는 곳이다

```shell
# readelf: ELF 파일의 계약 내용을 볼 수 있게 풀어주는 도구
$ readelf -S -W mult.o
There are 10 section headers, starting at offset 0x230:

Section Headers:
  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            0000000000000000 000000 000000 00      0   0  0
  [ 1] .strtab           STRTAB          0000000000000000 0001c9 000067 00      0   0  1
  [ 2] .text             PROGBITS        0000000000000000 000040 000028 00  AX  0   0  4
  [ 3] .rela.text        RELA            0000000000000000 000198 000018 18   I  9   2  8
  [ 4] .comment          PROGBITS        0000000000000000 000068 00002f 01  MS  0   0  1
  [ 5] .note.GNU-stack   PROGBITS        0000000000000000 000097 000000 00      0   0  1
  [ 6] .eh_frame         PROGBITS        0000000000000000 000098 000040 00   A  0   0  8
  [ 7] .rela.eh_frame    RELA            0000000000000000 0001b0 000018 18   I  9   6  8
  [ 8] .llvm_addrsig     LLVM_ADDRSIG    0000000000000000 0001c8 000001 00   E  9   0  1
  [ 9] .symtab           SYMTAB          0000000000000000 0000d8 0000c0 18      1   6  8
```

`.text` 이외에도 `.data`와 `.bss` 섹션을 살펴볼 수 있다

```c
// manySymbols.c

int myInitializedVar = 1;
int myUnitializedVar;

int add(int x, int y);

int mult(int x) { return add(x, x) ; }
```

```shell
$ clang --target=aarch64-linux-gnu -c -o manySymbols.o manySymbols.c
There are 12 section headers, starting at offset 0x2d0:

Section Headers:
  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            0000000000000000 000000 000000 00      0   0  0
  [ 1] .strtab           STRTAB          0000000000000000 000231 00009a 00      0   0  1
  [ 2] .text             PROGBITS        0000000000000000 000040 000028 00  AX  0   0  4
  [ 3] .rela.text        RELA            0000000000000000 000200 000018 18   I 11   2  8
  [ 4] .data             PROGBITS        0000000000000000 000068 000004 00  WA  0   0  4
  [ 5] .bss              NOBITS          0000000000000000 00006c 000004 00  WA  0   0  4
  [ 6] .comment          PROGBITS        0000000000000000 00006c 00002f 01  MS  0   0  1
  [ 7] .note.GNU-stack   PROGBITS        0000000000000000 00009b 000000 00      0   0  1
  [ 8] .eh_frame         PROGBITS        0000000000000000 0000a0 000040 00   A  0   0  8
  [ 9] .rela.eh_frame    RELA            0000000000000000 000218 000018 18   I 11   8  8
  [10] .llvm_addrsig     LLVM_ADDRSIG    0000000000000000 000230 000001 00   E 11   0  1
  [11] .symtab           SYMTAB          0000000000000000 0000e0 000120 18      1   8  8
```

### 오브젝트 파일이 함수, 변수를 심볼로 표현하는 방법

오브젝트 파일은 내보내는 심볼(export symbol)과 불러오는 심볼(import symbol)을 모두 리스트업하여 `.symtab` 섹션에 저장한다 (`.strtab` 섹션에서 문자열들로 참조함)

```c
$ // importExport.c

extern const int myConstant;
extern void foo(int x);

int myVar1;
int myVar2;
void bar() { 
    foo(myConstant); 
}
```

오브젝트 파일의 exported, imported 심볼은 `binutils`의 `nm`을 통해 살펴볼 수 있다
- 함수 `bar`: `.text` 섹션에 `0x0` 오프셋
- 초기화되지 않은 변수(`myVar1`, `myVar2`): `.bss` 섹션에 `0x0`과 `0x4` 오프셋 (4바이트) 
- imported 변수(`foo`, `myConstant`): 오프셋을 가지지 않는다

```shell
$ clang --target=aarch64-linux-gnu -c -o importExport.o ./importExport.c

$ nm importExport.o
0000000000000000 T bar
                 U foo
                 U myConstant
0000000000000000 B myVar1
0000000000000004 B myVar2
```

**`clang`과 `gcc`의 차이**

```c
// rainbow.c
extern int undVar;                 // Should be U  
int defVar;                        // Should be B

extern const int undConst;         // Should be U
const int defConst = 1;            // Should be R

extern int undInitVar;             // Should be U
int defInitVar = 1;                // Should be D

static int staticVar;              // Should be b
static int staticInitVar=1;        // Should be d
static const int staticConstVar=1; // Should be r

static void staticFun(int x) {}    // Should be t

extern void foo(int x);            // Should be U

void bar(int x) {                  // Should be T 
  foo(undVar);
  staticFun(undConst);
}
```

```shell
$ clang --target=aarch64-linux-gnu -c -o rainbow.o ./rainbow.c && nm rainbow.o
0000000000000000 T bar
0000000000000000 R defConst
0000000000000000 D defInitVar
0000000000000000 B defVar
                 U foo
000000000000003c t staticFun
                 U undConst
                 U undVar
```

```shell
$ gcc --target=aarch64-linux-gnu -c -o rainbow.o ./rainbow.c && nm rainbow.o
0000000000000000 T bar
0000000000000000 R defConst
0000000000000000 D defInitVar
0000000000000000 B defVar
                 U foo
000000000000003c t staticFun
                 U undConst
                 U undVar
```

**`nm`의 전체 심볼 리스트**

지역 심볼은 해당 오브젝트 파일에서만, 글로벌 심볼은 모든 오브젝트 파일에서 볼 수 있다

```text
A  A global, absolute symbol.
B  A global "bss" (uninitialized data) symbol.
C  A "common" symbol, representing uninitialized data.
D  A global symbol naming initialized data.
N  A debugger symbol.
R  A read-only data symbol.
T  A global text symbol.
U  An undefined symbol.
V  A weak object.
W  A weak reference.
a  A local absolute symbol.
b  A local "bss" (uninitialized data) symbol.
d  A local data symbol.
r  A local read-only data symbol.
t  A local text symbol.
v  A weak object that is undefined.
w  A weak symbol that is undefined.
?  None of the above.
```

### 강한 심볼과 약한 심볼

기본적으로 모든 심볼은 강한 심볼로 취급된다

따라서 아래와 같이 중복된 함수가 있는 경우 심볼이 중복되어 링커 단계에서 실패한다

```c
// weak_symbol.c
#include "stdio.h"

extern int getNumber();

int main() {
  printf("%d\n", getNumber());
}  
```

```c
// number1_strong_symbol.c
int getNumber() {
  return 1;
}  

// number2_strong_symbol.c
int getNumber() {
  return 2;
}    
```

```shell
$ clang -o weak weak_symbol.c number1_weak_symbol.c number2_weak_symbol.c
duplicate symbol '_getNumber' in:
ld: 1 duplicate symbols
clang: error: linker command failed with exit code 1 (use -v to see invocation)
```

그래서 둘 중 하나를 약한 심볼로 선언하면 컴파일/링킹 순서에 상관없이 정상적으로 컴파일 및 실행된다

```c
// number1_weak_symbol.c
// 약한 심볼 선언
__attribute__((weak)) int getNumber() {
  return 1;
}
```

```shell
$ clang -o weak weak_symbol.c ./number1_strong_symbol.c ./number1_weak_symbol.c
1
```


## 3. 링커: 모든 `.o` 파일, 라이브러리 머지 -> 실행 파일/공유 라이브러리/정적 라이브러리

링커는 컴파일러로부터 생성된 여러 개의 오브젝트 파일(`.o`)과 라이브러리(정적/동적)를 합쳐서 하나의 실행 가능한 파일을 만든다

컴파일러에 의해 만들어진 오브젝트 파일의 섹션 부분들을 병합한다

그 과정에서 정적 라이브러리로부터 누락된 심볼을 채우며 동적 라이브러리에서 가져온 심볼을 relocation한다

<img src="./images/ld.svg" alt="ld">


How the linker find resources ~

## 4. 로더: 실행 파일 -> 프로세스



## 컴파일러 드라이버 종류

C/C++: GCC, Clang(LLVM)

CUDA: NVCC

GNU Compiler Collection/GCC


## GNU

binutils

```text
// List of binutils tools

Name      |  Description
--------------------------------------------------------------
ld        |  The GNU linker.
as        |  The GNU assembler.
--------------------------------------------------------------
addr2line |  Converts addresses into filenames and line numbers.
ar        |  Creates, modifies and extracts from archives.
c++filt   |  Filter to demangle encoded C++ symbols.
dlltool   |  Creates files for building and using DLLs.
gold      |  New, faster, ELF only linker, 5x faster than ld.
gprof     |  Displays profiling information.
ldd       |  List libraries imported by object file.
nlmconv   |  Converts object code into an NLM.
nm        |  Lists symbols from object files.
objcopy   |  Copies and translates object files.
objdump   |  Displays information from object files.
ranlib    |  Generates an index to the contents of an archive.
readelf   |  Displays information from any ELF format object file.
size      |  Lists the section sizes of an object or archive file.
strings   |  Lists printable strings from files.
strip     |  Discards symbols.
windmc    |  Windows compatible message compiler.
windres   |  Compiler for Windows resource files. 
```