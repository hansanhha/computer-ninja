#### 인덱스
- [스트림](#스트림)
- [텍스트 스트림, 바이너리 스트림](#텍스트-스트림-바이너리-스트림)
- [텍스트 파일 입/출력 함수](#텍스트-파일-입출력-함수)
- [바이너리 파일 입/출력 함수](#바이너리-파일-입출력-함수)
- [패딩, 엔디안, sizeof 문제](#패딩-엔디안-sizeof-문제)

## 스트림

C에서 파일을 다룰 때는 `FILE*` 타입을 이용한다

C 스펙에선 실질적으로 입출력을 담당하는 요소를 **"스트림"**이라고 일컫는데, 스트림은 파일 또는 다른 소스가 될 수 있다

즉, 파일은 스트림의 한 형태이다

기본적으로 바로 사용할 수 있도록 제공되는 스트림 (표준 스트림)

|`FILE*` 이름|설명|
|---|----|
|`stdin`|표준 입력(키보드)|
|`stdout`|표준 출력(모니터)|
|`stderr`|표준 에러(모니터)|

## 텍스트 스트림, 바이너리 스트림

스트림은 크게 **텍스트**와 **바이너리** 방식으로 구분된다

일반적으로 텍스트 에디터에서 작성된 파일이 텍스트 파일이며, 나머지는 모두 바이너리로 취급된다
- 텍스트 파일: `.txt`, `.c`, `.h`, `.csv`, `.json`
- 바이너리 파일: `.exe`, `.png`, `.jpg`, `.zip`, `.pdf`

텍스트 스트림은 줄 단위로 구성된 문자가 들어있는 파일로, 각 줄은 개행 문자(`\n`)로 끝난다

-> **데이터는 문자 단위로 처리되며, 이들은 내부적으로 줄로 조직된다**

운영체제는 개행 문자를 자동을 변환하여 각 라인을 구분하는데 이 때 윈도우와 유닉스/리눅스의 개행 문자 변환 방식이 상이하다
- 윈도우: 텍스트 파일의 줄 끝을 `\r\n` (CR+LF, 2바이트)로 저장한다 (프로그램에서 `\n`을 넣으면 윈도우가 자동으로 `\r\n`으로 변환하고, 디스크에 저장된 `\r\n`을 읽어 프로그램에 `\n` 하나로 전달함)
- 유닉스/리눅스: `\n`(LF, 1바이트)만 사용한다

파일에 접근하려면 `fopen` 함수를 통해 읽을 파일의 경로와 작업 종류를 명시해야 한다

텍스트 파일은 기본적으로 읽기(`r`), 쓰기(`w`), 추가(`a`) 모드와

파일 존재 여부에 따라 다르게 동작하는 읽기/쓰기/추가 모드가 있다
- 읽기(`r+`): 파일이 존재하지 않으면 `NULL` 반환
- 쓰기(`w+`): 읽기 + 파일이 없으면 새로 생성, 있으면 기존 내용 모두 삭제
- 추가(`a+`): 읽기 + 파일이 없으면 새로 생성, 있으면 기존 내용 유지

지정한 작업 종류(모드)에 따라 초기 커서 위치가 지정된다

커서(File Position Indicator)는 파일 스트림(`FILE*`) 내부에 유지되는 현재 읽기/쓰기 위치를 가리키는 지표이다

파일 입출력 함수가 파일의 어느 위치부터 데이터를 읽거나 쓸지 결정한다

초기 커서 위치
- 읽기: 파일의 맨 처음(위치 0)
- 쓰기: 맨 처음
- 추가: 파일의 맨 끝

보통 문자 읽기 함수는 끝 줄 또는 EOF (End Of File)까지 파일을 읽는다

EOF란 파일의 끝을 나타내는 매크로 상수(`#define EOF (-1)`)로, 함수의 반환 값으로 사용되며 실제 파일에 "EOF"라는 바이트가 저장되지는 않는다

문자 읽기 함수가 더이상 읽을 문자가 없을 때, `fscanf()`나 `scanf()`가 읽을 데이터가 없거나 변환 실패 시 EOF를 반환한다

문자 기반 함수는 아래와 같이 반환 값이 EOF인지 확인하여 파일의 끝까지 읽은 것을 감지할 수 있다

```c
int ch;
while ((ch = fgetc(fp)) != EOF) {
    // code
}
```

---

바이너리 스트림은 이미지, 실행 파일, 압축 파일 등 비-텍스트 파일로, 바이트 단위로 읽고 쓰기 위해 설계된 입출력 모드이다

텍스트 스트림처럼 줄 개념이 없고, 개행 문자 변환을 운영체제가 개입하여 변환하지 않는다

프로그램에서 쓴 바이트가 디스크에 그대로 저장되고, 읽을 때도 그대로 반환된다

읽기 함수에서 더이상 읽을 바이트가 없으면 EOF를 바로 반환한다

**파일 열기 모드**

바이너리 파일은 각 모드의 문자 끝에 `b`를 붙여 지정한다 (각 모드는 텍스트와 거의 비슷하게 동작하지만 데이터 변환없이 그대로 읽고 씀)

|모드|특징|초기 커서 위치|기존 파일 위치|
|---|----|-------|----|
|rb|읽기 전용, 파일이 존재해야 한다|맨 처음|내용 보존|
|wb|쓰기 전용, 파일 없으면 생성/있으면 기존 내용 삭제|맨 처음|내용 삭제|
|ab|추가 전용, 파일 없으면 생성/있으면 기존 내용 유지|맨 끝|내용 보존|
|rb+, r+b|읽기 + 쓰기, 파일이 존재해야 하며 기존 내용을 덮어쓸 수 있다|맨 처음|내용 보존|
|wb+, w+b|읽기 + 쓰기, 파일 없으면 생성/있으면 기존 내용 삭제|맨 처음|내용 삭제|
|ab+, a+b|읽기 + 추가, 파일 없으면 생성/있으면 기존 내용 유지|맨 끝|내용 보존|

**바이너리 파일 주의사항**

`fread`, `fwrite`로 저장한 구조체는 [패딩, 엔디안, sizeof 문제](#패딩-엔디안-sizeof-문제) 때문에 다른 시스템에서 읽을 때 호환되지 않을 수 있다 

완전한 이식성을 이룰려면 텍스트 형식이나 네트워크 오더를 사용해야 한다


## 텍스트 파일 입/출력 함수

함수의 반환 타입, 파라미터는 동일하면서 함수 이름에서 `f`가 붙은 것과 붙지 않은 것이 있다

`f`가 붙은 함수(`fprintf`, `fscanf`, `fgetc` 등)는 임의의 파일 스트림(`FILE*`)을 대상 스트림으로 지정할 수 있다

반면, `f`가 붙지 않은 함수는 보통 `f`가 붙은 함수의 매크로 버전이다

함수 파라미터 리스트가 `void`인 함수는 표준 스트림(`stdin`, `stderr`, `stdout`)만 사용할 수 있다

그리고 반환 타입이 `int`, `char*`으로 결정된 기준은 아래와 같다
- `int`
  - 읽는 경우: 읽은 문자 `unsigned char`를 `int`로 변환 후 반환하거나 `EOF`(-1)를 구분하기 위함
  - 쓰는 경우: 성공한 경우 쓴 문자나 문자 수 반환, 실패 시 `EOF`(-1)를 반환하기 위함
- `char*`: 성공 시 읽은 버퍼 포인터 반환, 파일 끝/오류 시 `NULL` 반환

`unsigned char`의 범위는 0~255이고 `EOF`는 -1로 정의된다

만약 반환 타입이 `char`이라면 `char`이 `signed` 시스템에서 255(0xFF)가 -1로 해석되어 `EOF`와 혼동되는데, `unsigned`이더라도 -1을 표현할 수 없기 때문에 `int`를 사용한다

**문자 단위 입출력**
- `int fgetc(FILE *stream)`
- `int getc(FILE *stream)` (`fgetc`의 매크로버전)
- `int getchar(void)`
- `int fputc(int ch, FILE *stream)`
- `int putc(int ch, FILE (stream))` (`fputc`의 매크로버전)
- `int putchar(int ch)`
- `int ungetc(int ch, FILE *stream)`

**문자열 단위 입출력 함수**
- `char *fgets(char *str, int n, FILE *stream)`
- `int fputs(const char *str, FILE *stream)`
- `int puts(const char *str)`

**포맷 입출력 함수**
- `int fprintf(FILE *stream, const char *format, ...)`
- `int printf(const char *format, ...)`
- `int vfprintf(FILE *stream, const char *format, va_list arg)`
- `int fscanf(FILE *stream, const char *format, ...)`
- `int scanf(const char *format, ...)`
- `int vfscanf(FILE *stream, const char *format, va_list arg)`
- `int vscanf(const char *format, va_list arg)`

**파일 상태 및 제어 함수**
- `int fflush(FILE *stream)`: 버퍼 비우기
- `int fclose(FILE *stream)`
- `int fileno(FILE *stream)`: POSIX, 유닉스에서 파일 디스크립터 얻음


## 바이너리 파일 입/출력 함수

`size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)`
- 파일에서 `size` * `nmemb` 바이트를 읽어 `ptr`이 가리키는 메모리에 저장한다
- `size_t` 반환값은 읽은 요소 수를 반환한다 (0이면 EOF 또는 오류 반환)

`size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)`
- `ptr`이 가리키는 메모리에서 `size` * `nmemb` 바이트를 파일에 쓴다
- `size_t` 반환값은 쓴 요소 수를 반환한다 (`nmemb`보다 작으면 오류 발생)

```c
#include <stdio.h>

typedef struct {
    int id;
    double value;
    char name[20];
} Record;

int main(void) {

    Record rec = {100, 3.14, "Test"};
    Record read_rec;

    FILE *fp = fopen("data.bin", "wb");
    if (fp) {
        fwrite(&rec, sizeof(Record), 1, fp);
        fclose(fp);
    }

    fp = fopen("data.bin", "rb");
    if (fp) {
        size_t read_count = fread(&read_rec, sizeof(Record), 1, fp);
        if (read_count == 1) {
            printf("ID: %d, Value: %.2f, Name: %s\n", read_rec.id, read.value, read_rec.name);
        }
        fclose(fp);
    }
}
```


## 패딩, 엔디안, sizeof 문제

C 언어에서 `fread`, `fwrite`로 구조체를 그대로 바이너리 파일에 저장하면 시스템(OS, CPU 아키텍처, 컴파일러)마다 패딩, 엔디안, sizeof를 처리하는 방식이 달라서 그 파일을 읽을 때 정확히 같은 데이터로 복원되지 않을 수 있다

**패딩 (Padding)**

컴파일러는 구조체 멤버를 메모리 정렬을 위해 자동으로 빈 바이트를 삽입한다

아래의 구조체는 `int`에 대한 4바이트 정렬을 위해 각 `char`마다 3바이트 패딩이 들어간다

결과적으로 `sizeof(struct Example)`은 12바이트가 된다(1 + 3패딩 + 4 + 1 + 3패딩)

```c
struct Example {
    char a;  // 1바이트
    int c;   // 4바이트
    char c;  // 1바이트
}
```

문제는 다른 컴파일러나 다른 컴파일 옵션(`#pragma pack` 등)을 쓰면 패딩 크기가 달라질 수 있다

`fwrite`로 저장하면 패딩 바이트까지 그대로 저장되므로 패딩이 다른 시슽메에서 읽으면 멤버 위치가 어긋나서 잘못된 값이 읽힌다

**엔디안 (Endianness)**

엔디안은 바이트 순서를 정하는 방법이다

빅 엔디안(Big Endian)은 가장 중요한 바이트(MSB)를 먼저 저장한다 (PowerPC, 일부 네트워크 프로토콜에서 사용)

리틀 엔디안(Little Endian)은 가장 덜 중요한 바이트(LSB)를 먼저 저장한다 (대부분의 PC에서 사용)

```c
int value = 0x12345678;

// 리틀 엔디안: 78 56 34 12
// 빅 엔디안: 12 34 56 78
```

리틀 엔디안 시스템에서 `int`를 `fwrite`로 저장하면 바이트 순서가 `78 56 34 12`로 저장된다

이후 빅 인디안 시스템에서 그 파일을 읽으면 `0x12345678`이 아니라 `0x78563412`라는 전혀 다른 값이 된다

**sizeof와 기본 타입 크기 차이**

C 표준은 기본 타입의 크기를 최소 크기만 보장한다

`int`: 최소 16비트, 대부분 32비트 -> 어떤 시스템에서 16비트 일 수 있음

`long`: 최소 32비트, 32비트/64비트(OS 지원에 따라 다름) 

`pointer`: 32비트 또는 64비트 -> 구조체에 포인터 포함 시 크기가 다를 수 있음

같은 소스 코드를 다른 플랫폼에서 컴파일하면 `sizeof(int)`나 `sizeof(long)`의 값이 달라질 수 있다

띠라서 구조체 전체 크기가 달라지므로 바이너리 파일이 호환되지 않는다

---

`fwrite()`, `fread()`로 데이터를 바이너리 파일에 직접 쓰는 대신 데이터를 직렬화하면 이러한 문제를 해결할 수 있다

JSON, CSV 등 텍스트 형식 사용: 가장 안전하지만 성능/용량 효율이 떨어진다

고정 크기 타입 사용 (`stdint.h`): 크기가 명확히 고정되나 여전히 패딩이 있을 수 있다

```c
#include <stdint.h>
struct Data {
    int8_t flag;
    int32_t id;
    int64_t value;
}
```

패딩 제거 (`#pragma pack` 또는 `attribute((packed))`)

```c
#pragma pack(push, 1)
struct Data { ... };
#pragma pack(pop)
```

엔디안 변환 함수 사용: `htons()`, `htonl()`, `ntohs()`, `ntohl()` 등
