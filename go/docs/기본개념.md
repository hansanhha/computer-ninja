#### 목차
- [프로그래밍 개념](#프로그래밍-개념)
- [컴파일 언어](#컴파일-언어)
- [정적 타입 언어](#정적-타입-언어)
- [Go의 주요 구성 요소](#go의-주요-구성-요소)
- [표현식(Expression)과 문장(Statement)](#표현식expression과-문장statement)


## 프로그래밍 개념

[이 글](https://go101.org/article/basic-code-elements-introduction.html)의 첫 번째 단락을 참고하면 프로그래밍과 소스 코드 요소에 대한 개요를 살펴볼 수 있다

내용을 간략하게 정리하자면 다음과 같다
- 고수준 프로그래밍 언어는 주로 함수와 연산자 호출에 의해 이루어지는데, 여기엔 몇 가지 종류의 조건문과 제어문이 포함되어 인간이 이해하기 쉽게 코드를 작성할 수 있다 (저수준 언어에 비해)
- 데이터는 타입과 값에 의해 추상화되며 타입은 값의 템플릿으로 볼 수 있고 값은 타입의 인스턴스로 볼 수 있다
- 대부분의 언어는 내장된 타입이 있으며 커스텀 타입을 지원한다 (객체)
- 함수, 값(변수), 커스텀 타입은 코드 요소(code element)라고 부르며 각 코드 요소의 이름은 **식별자** 가 되어야 한다 (패키지와 import한 패키지의 이름도 마찬가지)
- 언어는 자체적으로 제공하는 기능의 이름이 식별자로 사용되는 것을 방지하기 위해 미리 예약된 **키워드** 를 정의한다
- 패키지는 코드를 깔끔하게 정리하기 위해 사용되며, 특정 패키지가 다른 패키지에서 외부에 공개한 코드 요소를 사용하려면 가져와야 한다 (**import**)


## 컴파일 언어 

Go는 컴파일 언어이고 정적 타입 언어이다

프로그래머가 작성한 소스 코드를 컴퓨터가 실행할 수 있는 기계어 코드나 중간 코드(바이트코드 등)로 변환하는 컴파일 과정을 거친 후 실행되는 언어를 컴파일 언어라고 한다

`소스 코드 -> 컴파일러 -> 기계어`

이 때, 변환 작업을 수행하는 소프트웨어를 컴파일러라고 한다 (Go는 어셈블리어와 어셈블러 호출 단계를 건너뛰고 컴파일러 자체가 직접 기계어 코드를 생성함)

`어휘 분석 -> 구문 분석 -> 의미 분석 -> 중간 코드(IR) 생성 -> 코드 최적화 -> 기계어 코드 생성 -> 링크`

컴파일러는 구문 분석, 의미 분석, 최적화 등의 과정을 거쳐 최종적으로 특정 운영체제와 CPU 아키텍처에 맞는 실행 가능한 바이너리 파일로 변환한다

컴파일 언어는 다음과 같은 장점을 가진다
- 코드를 미리 기계어로 변환하기 때문에 파일 실행 시 변환 과정없이 즉시 CPU가 명령을 처리할 수 있어 매우 빠르다
- 컴파일 시점에 문법적 오류나 논리적 오류(타입 불일치)를 미리 발견할 수 있으므로 런타임 오류를 줄일 수 있다
- 컴파일러가 전체 코드를 분석하여 실행 성능을 최적화할 수 있는 기회를 가진다

대신 이런 단점을 지닌다
- 코드를 수정할 때마다 전체를 다시 컴파일해야 하므로 개발 과정에서 작은 수정에도 빌드 시간이 필요하다 (Go는 컴파일 시간이 빠르기 때문에 이러한 단점을 어느정도 상쇄한다)
- 생성된 바이너리 파일은 아키텍처에 종속적이다 (Go는 크로스 컴파일 기능을 지원한다)


## 정적 타입 언어

정적 타입 언어는 변수나 표현식의 데이터 타입이 컴파일 시점에 결정되는 언어를 말한다

변수를 선언할 때 해당 변수가 어떤 타입의 데이터를 담을 것인지 명시적으로 지정해야 하고, 컴파일러는 이 정보를 통해 타입 규칙을 검사하고, 규칙을 위반하는 코드가 있다면 컴파일 에러를 발생시킨다

Go는 타입 추론을 지원하여 타입을 생략할 수 있지만 이는 컴파일러가 사용되는 값을 보고 값을 추론하는 것이며 타입이 런타임에 결정되는 것이 아니다


## Go의 주요 구성 요소

Go는 **세 가지 핵심 철학(간결성, 효율성, 동시성)** 을 기반으로 개발 생산성을 높이면서도 C++과 같은 저수준 언어와 비슷한 성능을 제공하려는 목표를 가진다

### 간결한 문법 및 타입 시스템

Go는 C++이나 자바와 같은 언어에서 제공하는 복잡한 기능(클래스 상속, 오버로딩 등)을 덜어내어 코드 예측 가능성과 코드의 이해도를 높인다 

정적 타입 언어이므로 컴파일 시점에 모든 변수의 타입이 결정된다 -> 런타임 오류를 방지하고 코드의 안정성을 높인다

또한 `:=`와 같은 구문을 통해 타입 추론을 지원하여 코드를 간결하게 작성할 수 있게 한다

Go는 클래스 상속 대신 인터페이스를 통해 다형성을 구현한다

특정 인터페이스에 정의된 메서드를 모두 구현하는 구조체(struct)는 해당 인터페이스를 자동으로 만족시킨다 -> 유연하고 확장 가능한 설계를 할 수 있는 느슨한 결합(Loose Coupling)을 유도한다


### 동시성 모델: 고루틴과 채널

고루틴은 Go에서 제공하는 유저 스레드(Green Thread)로 수 KB의 스택 공간을 시작으로 필요에 따라 동적으로 크기를 확장하거나 축소할 수 있다

Go 런타임이 수백만 개의 고루틴을 효율적으로 스케줄링하여 몇 개의 커널 스레드에 매핑한다 (M:N 매핑 모델)

이러한 경량성 덕분에 대규모 동시 작업을 처리하는 서버 애플리케이션에 적합하다 (C++에 준하는 간단한 시스템 프로그래밍 언어로 만들려던거 아니었나..?)

채널은 고루틴 간에 데이터를 안전하게 통신하고 동기화하는 데 사용되는 **타입이 지정된 통신 파이프** 이다

Go는 메모리 공유를 통해 통신하지말고, 통신하여 메모리를 공유하라는 동시성 철학을 가지는데 이를 채널을 통해 구현하여 공유 메모리 동시성 모델에서 발생할 수 있는 동기화 문제를 방지한다

### 메모리 관리: 가비지 컬렉션

Go는 자동 메모리 관리를 위해 내장된 가비지 컬렉터를 사용한다

개발자가 메모리 할당 및 해제를 수동으로 관리할 필요가 없어 메모리 누수를 방지할 수 있다

가비지 컬렉터의 최대 단점은 작동 중 애플리케이션의 실행을 멈추는 것인데 (Stop-the-World) Go는 고루틴과 증분(Incremental) 방식을 활용하여 중단되는 시간을 최소화한다


### 컴파일 및 배포

Go 컴파일러(gc)는 컴파일 언어치고 상당히 빠르기 때문에 자주 빌드할 수 있어 개발 주기를 단축시키는 데 기여한다

또한 모든 의존성 라이브러리(표준 라이브러리 포함)를 하나의 단일 바이너리 실행 파일로 묶는다 (정적 링크)

이 방식은 대상 시스템에 Go 런타임이나 추가 라이브러리를 설치할 필요없이 파일 하나만 복사하면 되기 때문에 배포가 매우 간편해진다 -> 컨테이너에 환경에 적합하다. 다만 실행 파일의 크기가 상대적으로 커질 수 있다

Go는 다른 운영체제나 아키텍처용 바이너리를 쉽게 컴파일할 수 있는 크로스 컴파일(Cross-Compilation) 기능을 내장하고 있다 (e.g 맥에서 리눅스 서버용 실행 파일을 만들 수 있음)


## 표현식(Expression)과 문장(Statement)

**표현식**은 어떤 값이든 생산(produce)하는 코드의 조각을 말한다

특정 시점에 평가(evaluate)되었을 때 하나의 값을 결과로 반환하는 모든 것을 표현식이라고 한다 -> 표현식은 평가되면 반드시 특정 데이터 타입의 값을 반환한다

리터럴(`"hello`,`100`, `false`), 변수(`x`, `name`), 연산자 연산(`a + b`, `^100`, `x > 10`), 함수 호출(`len("go)`, `add(10, 20)`), 배열/슬라이스/맵 인덱싱(`arr[0]`, `m["key"]`) 등은 표현식이 된다

값을 반환하는 함수 호출만 표현식이 되며 값을 반환하지 않는 함수 호출은 표현식이 될 수 없다 

Go의 함수는 여러 값을 반환할 수 있는데, 이러한 함수 호출은 다중 값 표현식(Multi-value expression)이 된다

**문장**은 어떤 작업을 수행하는 코드의 실행 단위로, 문장은 여러 표현식과 하위 문장을 포함할 수 있다

값을 반환할 수도 있고, 반환하지 않을 수도 있기 때문에 값의 반환 여부를 떠나 프로그램 상태 변경, 입출력 작업, 코드 흐름 제어 등 무언가를 지시하고 행동을 유발한다면 그게 문장이 될 수 있다

변수 선언(`var x int`), 할당(`x = 10`, `10`은 표현식), 함수 호출(`fmt.Println("hello")`), 제어 흐름 문장(`if-else`, `for`, `switch`), 코드 블록(`{}`), 반환 (`return value`) `a++`, `a--` 등은 문장이 된다

함수/메서드 호출, 채널 수신 연산 등은 문장이자 표현식이 될 수 있다