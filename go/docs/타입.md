#### 목차
- [Go의 타입 시스템 개요](#go의-타입-시스템-개요)
- [익명 타입(Unamed Type)과 네임드 타입(Named Type)](#익명-타입unamed-type과-명명된-타입named-type)
- [기반 타입(Underlying Type)](#기반-타입underlying-type)
- [원시 타입](#원시-타입)
- [문자열 타입](#문자열-타입)
- 복합 타입
    - [포인터](#포인터)
    - [구조체](#구조체)
    - [함수](#함수)
    - [컨테이너: 배열, 슬라이스, 맵](#컨테이너-배열-슬라이스-맵)
    - [채널](#채널)
    - [메서드](#메서드)
    - [인터페이스](#인터페이스)
- [타입 임베딩](#타입-임베딩)
- [런타임 타입 검사: 타입 어설션, 타입 스위치](#런타임-타입-검사-타입-어설션-타입-스위치)


## Go의 타입 시스템 개요

Go의 타입은 자바와 같은 객체지향을 기반으로 둔 언어의 타입과는 조금 다른 관점으로 접근해야 한다

### 명목적 타이핑과 구조적 타이핑

프로그래밍에서 타입은 데이터의 종류와 그 데이터로 수행할 수 있는 연산의 집합을 정의한다

e.g 정수형(Integer) 타입은 숫자를 저장하고 덧셈, 뺄셈 등의 연산을 의미한다

타이핑은 이러한 타입들이 서로 어떻게 호환되는지, 또는 특정 문맥에서 어떤 타입이 허용되는지 결정하는 언어의 메커니즘을 말한다

이는 크게 정적 타이핑과 동적 타이핑의 범주로 나눌 수 있다
- 정적 타이핑: 컴파일 시점에 타입 검사가 이루어진다 (Go, 자바, C++ 등)
- 동적 타이핑: 런타임 시점에 타입 검사가 이루어진다 (파이썬, 자바스크립트 등)

정적 타이핑(Go)은 다시 **명목적 타이핑(Nominal Typing)** 과 **구조적 타이핑(Structural Typing)** 으로 구분된다

**명목적 타이핑** 은 두 타입이 "같은 이름"을 가지고 있거나 "명시적인 선언"을 통해 관련이 있음을 나타내야만 서로 호환되거나 같다고 간주한다 (이름이 중요한 기준이 된다)

두 타입의 이름이 다른 경우에 개발자가 `extends`, `impements`와 같은 키워드를 사용하여 타입 간의 관계를 명시적으로 선언해야 한다

주로 클래스 기반의 상속 계층과 밀접하게 관련이 있다

**Go, 자바, C++ 등이 구조적 타이핑** 을 기반으로 한다

**구조적 타이핑(Structural Typing)** 은 두 타입이 "동일한 구조" (동일한 필드와 메서드)를 가지고 있다면 서로 호환되거나 같다고 간주한다

이름보다 타입의 형태(Structure)가 중요한 기준이 된다

이를 덕 타이핑(Duck Typing)이라고도 하는데, "오리처럼 걷고 오리처럼 꽥꽥거린다면 그것은 오리다" 라는 비유에서 유래했다

구조적 타이핑에선 타입 간의 관계를 명시적으로 선언할 필요가 없고, 구조가 일치하면 자동으로 호환된다

불필요한 상속 계층을 피하고 코드를 유연하게 작성할 수 있다

또한 기존 코드를 수정하지 않고도 새로운 인터페이스를 만족시키거나 호환되게 만들 수 있다

**Go의 인터페이스가 명목적 타이핑** 을 따른다

### 자바가 타입을 바라보는 관점

자바에서의 타입은 객체를 정의하기 위한 **청사진(Blueprint)** 에 가깝다 (여기서 말하는 타입은 참조 타입으로만 제한둔다)

객체를 중심으로 모든 것을 바라보고, 객체가 어떤 데이터(필드)로 이루어지고 어떤 행동(메서드)를 할지 상세하게 정의한다

그리고 `extends`나 `implements` 키워드를 통해 객체들을 상하 관계의 **계층(Hierarcy)** 으로 연결한다

객체의 필드와 메서드는 접근 제어자를 통해 접근 범위를 상세하게 설정할 수 있다

```java
// Book 객체 정의
class Book {

    // Book 객체가 가지는 데이터(필드) 정의
    protected String title;
    protected int price;

    // Book 객체가 할 수 있는 동작(메서드) 정의
    public void updatePrice(int price) {
        this.price = price;
    }
}

// TextBook은 Book을 물려받는다 (상속)
class TextBook extends Book {

    // 자신만의 필드와 메서드를 정의한다
    int grade;

    public void updateGrade(int grade) {
        this.grade = grade;
    }
}

// 인터페이스는 "역할"에 대한 계약을 의미한다 
// 구현체는 반드시 implements 키워드를 사용하여 인터페이스에 정의된 모든 메서드를 구현할 것을 "계약"한다
interface Greetable {
    void greet();
}

class EnglishSpeaker implements Greetable {
    @Override
    public void greet() {
        System.out.println("Hello!");
    }
}
```

자바에서 `Book` 타입과 `TextBook` 타입은 `extedns` 관계이고, `EnglishSpeaker`는 `implements`로 `Greetable`과 묶여있다 -> 타입의 이름과 타입 간의 관계가 굉장히 중요하고 명시적이다

### Go에서 타입을 바라보는 관점

Go는 자바와 사뭇 다르게 타입을 데이터와 행동을 분리된 관점에서 바라본다

`struct`로 데이터 구조를 정의하고 `interface`로 행동의 계약을 정의한다

하지만 자바처럼 객체가 인터페이스와 강한 계약을 맺지 않고 암시적 구현이라는 개념을 사용한다

여러 블록을 붙여서 레고를 완성하듯이, 타입을 선언한 뒤 특정 함수에 타입을 매핑하여 해당 타입이 수행할 수 있는 연산을 정의한다

이러한 연산이 타입의 메서드가 되며 특정 타입의 메서드 집합이 인터페이스에 정의된 메서드 집합을 만족하면 그게 인터페이스 구현이 된다 (암시적 구현)

또한 **Go에는 상속이라는 개념이 없다** 는 것이다

대신 **임베딩(Embedding)** 과 **인터페이스** 를 사용하여 상속과 다형성을 대체한다

Go와 자바가 타입을 다루는 방식에 대한 차이를 좀 더 알아보자

#### 타입 선언 키워드가 다르다

자바에서 타입을 정의할 때 객체 상속, 목적에 따라 `interface`, `class`, `record`를 사용한다

Go는 간결하게 `type` 키워드만 사용한다

#### Go에서는 타입을 무조건 객체로써 정의하지 않아도 된다

Go에서는 `int`, `string`, `bool` 같은 내장 타입을 기반으로 새로운 이름을 붙여 독자적인 타입을 만들 수 있다

이게 당최 무슨 말인지 이해가 안될 수 있다

자바에서 `int` 타입의 필드를 가진 클래스를 아래와 같이 정의할 수 있다

여기에 메서드를 추가함으로써 객체의 행동을 유발할 수도 있다

```java
class Meter {
    int value
}

class Centimeter {
    int value
}
```

Go에서는 객체(구조체)를 만들지 않고 `int` 타입을 기반으로 하는 새 타입을 아래와 같이 정의할 수 있다

특정 타입에 이름(별칭)을 붙임으로써 코드의 가독성을 높이거나 특정 도메인에 맞는 의미를 부여할 수 있다

```go
type Meter int      // Meter != int
type Centimeter int      // Meter != int

var m Meter = 1
var cm Centimeter = 100
```

타입 자체가 `int` 형으로 동작하지만 새로 만들어진 타입은 기존 타입과 다른 타입으로 취급된다

Go에서는 이런 타입을 

그저 `int`와 똑같은 내부 구조를 가진 새로운 이름표가 붙은 타입을 하나 정의한 것뿐이며, Go 컴파일러는 `int`와는 완전히 다르고 독립적인 새 타입으로 취급된다

#### Go는 클래스 대신 구조체를 사용한다

Go에서 데이터를 포함하는 객체를 정의하려면 자바의 `class`가 아닌 C 언어처럼 구조체(`struct`)를 사용해야 한다

```go
type Book struct {
    title string
    price int
} 

b := Book{title: "golang", price: 10_000}
```

Go가 클래스 대신 구조체를 사용함으로써 자바와 2가지의 두드러진 차이점을 가진다

첫 번째는 **구조체와 메서드를 분리** 한다는 것이다 (행동을 구조체 내에 정의하지 않는다)

자바처럼 클래스에 필드와 메서드를 정의하고, 상속/계약 메커니즘을 이용하여 부모의 필드와 메서드를 물려받거나 다형성을 활용하지 않는다

대신에 Go는 구조체에 데이터만 정의하고(C 언어처럼) 메서드를 구조체 외부에 리시버를 통해 함수와 구조체를 연결함으로써 정의한다

이로써 구조체는 순수하게 데이터의 집합이 되고 특정 행동은 그 데이터에 의존하지 않고도 정의될 수 있다 -> 구조체 스펙을 변경하지 않고도 새로운 행동을 추가하거나 기존 행동을 수정하기 쉽게 만든다

또한 구조체 뿐만 아니라 기본 타입(`int`, `string`) 등 모든 타입에 메서드를 연결할 수 있다 -> 자바에서 `Integer` 클래스처럼 래퍼 클래스를 만들어야 메서드를 추가할 수 있는 것과 대조적이다

Go가 동시성 프로그래밍에 강점을 가지는 이유는 데이터와 행동을 분리함으로써 공유 상태 관리의 복잡성을 줄이기 때문이다 -> 구조체를 순수한 데이터 컨테이너로써 사용하여 공유 메모리에 대한 동시 접근을 제어하기 더 용이하다

두 번째는 **클래스 기반의 상속(`is-a` 관계)을 지원하지 않고 합성/조합(`has-a` 관계)를 사용** 한다는 것이다

Go는 구조체의 임베딩을 통한 조합(Composition)을 주로 사용한다

이는 상속으로 인한 발생하는 강한 결합을 제거하고 다중 구현을 가능하게 한다

상속은 부모 클래스의 `private`을 제외한 필드와 메서드를 물려받지만, 조합(합성)은 필요한 부분만 가져와 사용할 수 있다

`is-a`는 "A는 B이다" 라는 분류적 관계를 나타내고 `has-a`는 "A는 B를 가지고 있다" 라는 구성적 관게를 나타낸다

`has-a` 관계는 객체의 내부 구성을 명확하게 보여주어 시스템 작동 방식을 비교적 이해하기 쉽게 한다

이외에도 코드 복잡성 감소, 테스트 용이성 등의 장점을 가진다

```go
// Engine이라는 구조체 정의
type Engine struct {
    Horsepower int
}

// Engine 구조체에 메서드(함수 연결) 정의
func (e Engine) Start() {
    fmt.Println("엔진 가동, 마력:", e.Horsepower)
}

// Car 구조체 정의, Engine 구조체를 포함한다 (임베딩)
// `Car` 구조체 안에 `Engine` 구조체를 이름을 생략하고 통째로 넣으면 `Car`이 `Engine`의 데이터와 메서드에 접근할 수 있다
type Car struct {
    Engine // Engine 구조체를 통째로 넣고 이름을 생략한다
    Brand string
}

func main() {
    // Car 구조체를 만들 때 Engine 구조체도 함께 생성한다
    tesla := Car{
        Engine: Engine{Horsepower: 200},
        Brand: "Tesla",
    }

    // Car 구조체가 직접 Engine 구조체의 Start 메서드를 호출한다
    tesla.Start()
}
```

#### Go는 데이터와 함수를 이렇게 분리한다

Go는 함수와 메서드 모두 지원한다

함수는 **특정 타입에 연결되지 않은 함수** 이며 범용적으로 사용될 수 있다

메서드는 **특정 타입에 연결된 함수**로, 연결된 해당 타입에 대해서 사용될 수 있다 (특정 타입은 구조체, 별칭 타입 등이 될 수 있다)

```go
// 일반 함수
func greeting() {
    fmt.Println("hello golang")
}

type Meter int

// Meter 타입과 연결된 메서드
func (m Meter) ToCentimeter() Centimeter {
    // Centimeter()는 생성자가 아니라 명시적 변환을 수행하는 표현식이다
    return Centimeter(m * 100) 
}
```

### 값 부분(Value Parts)과 Go 타입의 두 가지 카테고리

Go는 C 계열 언어로써 구조체 타입과 포인터 타입의 메모리 구조가 C 언어와 매우 유사하지만 다음과 같은 차이점을 가진다

C 언어는 저수준 메모리 모델을 직접적으로 반영하는 경향이 강하다

구조체나 배열 같은 복합 타입은 대부분 메모리 상에 연속적인 단일 블록으로 배치된다 -> 해당 타입의 모든 데이터가 한 덩어리로 붙어있다

반면 Go 언어의 몇 가지 타입은 **개념적으로는 단일 값**처럼 다루어지지만 **실제 메모리에서는 여러 개의 분리된 메모리 블록에 걸쳐** 데이터가 저장될 수 있다

분리된 메모리 블록들을 해당 값의 부분이라고 하여 **값 부분(Value Parts)**라고 부른다 (인터페이스 값, 슬라이스 값 등)

즉, 값 부분이란 Go 언어의 특정 타입에서 하나의 값을 이루지만 (추상화) 실제 메모리 상에서는 분리되어 존재할 수 있는 여러 메모리 블록들을 지칭하는 것이다

값 타입은 크게 Direct Value Part와 Underlying Indirect Value Part로 나뉜다

**직접 값 부분(Direct Value Part)** 은 어떤 변수나 함수 인자가 직접적으로 저장하는 부분을 의미한다

대부분의 기본 타입과 포인터 타입이 직접 값 부분, 변수 자체의 메모리 공간에 값이 직접 저장된다

슬라이스, 맵, 채널, 인터페이스와 같은 Go의 내장 참조 타입들은 변수 자체에 해당 데이터의 헤더 또는 디스크립터를 저장한다

이 헤더 또는 디스크립터는 실제 데이터가 있는 메모리 주소(포인터), 길이, 용량 등의 메타데이터로 구성된다

실제 데이터는 헤더 외부에 있는 다른 메모리 블록에 저장된다

**하부 간접 부분(Underlying Indirect Value Part)** 은 직접 값 부분 내부의 포인터가 가리키는 실제 데이터가 저장된 메모리 블록을 의미한다

직접 값 부분이 저장된 메모리 공간과는 별개의 독립적인 메모리 공간에 존재하며, 크기가 가변적이며 데이터의 양에 따라 동적으로 할당되고 확장될 수 있다 (여러 개의 하부 간접 부분으로 구성될 수 있다)

슬라이스 요소들, 맵의 키-값 쌍, 채널의 버퍼, 인터페이스가 감싸고 있는 실제 구체적인 값 등 가변적이거나 큰 크기의 실제 데이터가 여기에 저장된다

따라서 Go 언어에서는 타입의 메모리 모델과 관련하여 크게 두 가지 카테고리로 나뉜다

한 가지는 단일 메모리 블록에 데이터를 저장하는 타입이고, 다른 한 가지는 위의 설명처럼 여러 메모리 블록에 데이터를 저장하는 타입이다

##### 단일 값 부분 타입 `Solo Direct Value Part`
- 불린
- 숫자
- 포인터
- unsafe 포인터
- 구조체
- 배열

##### 다중 값 부분 타입 `Direct Value Part` -> `Underlying Indirect Value Part` N개
- 슬라이스
- 맵
- 채널
- 함수
- 인터페이스
- 문자열

Go가 이렇게 값 부분(Value Parts)이라는 디자인을 채택하여 다음과 같은 장점을 갖게 된다

**메모리 효율성과 성능**: 인터페이스, 슬라이스, 문자열과 같이 크기가 가변적이거나 동적으로 변경될 수 있는 타입을 함수나 변수에 할당할 때 전체 데이터를 복사하는 대신 **헤더(포인터와 길이)** 만 복사하면 된다 (C 언어에서는 직접 포인터를 전달하거나 배열 크기를 명시해야 한다)

**가비지 컬렉션**: Go의 가비지 컬렉터는 '값 부분'들이 가리키는 실제 데이터 블록들의 생명주기를 자동으로 관리하여 메모리 누수를 방지한다

**런타임 안정성**: 슬라이스나 문자열 접근 시 길이나 용량 정보를 헤더에서 직접 얻을 수 있으므로 Go 런타임은 인덱스 범위 검사를 자동으로 수행하여 버퍼 오버플로우와 같은 문제를 방지한다

### 값 복사 동작 원리

Go에서 파라미터 전달을 포함한 값 할당은 얕은 복사(Shallow Copy)로 이뤄진다 (만약 자료형이 서로 다른 경우 할당되기 전 암묵적인 형변환이 먼저 이뤄진다)

즉, 값 할당 시 값을 할당하는 직접 값 부분(Source Direct Value Part)만이 할당하려는 부분(Destination Value)에 복사된다

만약 할당하는 값이 하부 값 부분(Underlying Value Part)이라면 할당된 값과 할당한 값 모두 같은 하부 값 부분을 참조하게 된다 (두 값 모두 동일한 하부 값 부분을 공유하게 된다)

요약 설명
- 함수의 모든 파라미터는 복사에 의한 할당이 이뤄진다 (Direct Part)
- 값 부분은 하나의 메모리 블록에 데이터를 저장하는 직접 값 부분(Direct Value Part)과 직접 값 부분에 포인터 등의 헤더를 저장하고 여러 개의 메모리 블록에 데이터를 저장하는 하부 값 부분(Underlying Value Part)로 나뉘며, 이 값 부분은 자료형에 따라 사용된다
- 값 복사는 얕은 복사만 하기 때문에 직접 값 부분만 복사된다
- 하부 값 부분은 복사되지 않으며, 인터페이스나 문자열같이 하부 값 부분을 사용하는 자료형을 값 할당하면 해당 데이터에 대한 헤더(Direct Value Part)만 공유하게 된다


## 익명 타입(Unamed Type)과 네임드 타입(Named Type)

**익명 타입(이름 없는 타입)** 은 명시적인 이름 없이 구조나 형태만으로 정의된 타입이다 (자바의 익명 클래스, 람다식 느낌)

주로 임시적으로 사용하거나 특정 목적을 위해 한 번만 사용해야 할 필요가 있는 경우에 활용된다

정의되는 시점에 바로 사용되며 다른 곳에서 이름을 통해 참조될 수 없다

익명 타입간 구조가 동일하면 호환될 수 있다

```go
point := struct {
    x int
    y int
}{x: 10, y: 20}

// point와 동일한 구조의 또다른 익명 타입
point2 := struct {
    x int
    y int
}{x: 30, y: 40}

// Go에서는 동일한 구조의 익명 타입끼리 호환된다 (네임드 타입은 구조가 같아도 안된다)
point = point2

add := func(a, b int) int {
    return a + b
}

result := add(10, 20)

// 배열 타입, 슬라이스 타입 (타입 리터럴 표현)
var numbers []int 	// []int는 슬라이스 타입의 익명 타입이다
var matrix [3][3]float64 // [3][3]float64는 배열 타입의 익명 타입이다
```

**네임드 타입(Named Type)**은 `type` 키워드 등을 사용하여 명시적으로 이름을 부여한 모든 타입을 말한다 (자바의 클래스 느낌)

네임드 타입은 독립적인 타입으로 기반 타입과 별개의 취급을 받는다

이름을 통해 프로그램 전체에서 타입을 참조하고 재사용할 수 있다

네임드 타입은 컴파일러에 의해 엄격하게 구분되어 내부 구조가 같더라도 서로 다른 네임드 타입은 호환되지 않는다

Go에서는 네임드 타입에만 메서드를 연결할 수 있다 -> 특정 타입에 특정 동작을 부여할 수 있다

```go
type status bool     // 기본 타입의 별칭
type MyString string // 기본 타입의 별칭

type Point struct {	 // 구조체 타입
	x int
	y int
}

type PointQueue []Point // 슬라이스 타입
type WordDictionary map[string]string // 맵 타입
type Greeter func(name string) string // 함수 타입
```



## 기반 타입(Underlying Type)

Go 언어에서 기반 타입은 `type` 키워드를 사용하여 새로운 네임드 타입(Named Type)을 정의할 때, 그 새로운 타입이 무엇으로부터 파생되었는지를 나타내는 원래의 타입(original type)을 의미한다

`type NewType OldType` 에서 `OldType`이 `NewType`의 기반 타입이 된다

Go 언어의 타입 시스템에서는 명목적 타이핑과 구조적 타이핑의 특성을 모두 가지고 있다

대부분 명목적 타이핑을 따르기 때문에 `type` 키워드로 정의된 새로운 타입은 내부 구조가 같더라도 원래의 타입과 별개의 타입으로 취급된다

대신 새로운 네임드 타입은 기반 타입의 내장된 연산을 사용할 수 있다

e.g `var MyInt int` 타입은 `int`를 기반으로 하는 덧셈, 뺄셈 등의 산술 연산을 할 수 있다

기반 타입이 인터페이스를 만족하는 것과는 별개로 새로운 네임드 타입은 자체적으로 인터페이스를 만족해야 한다

```go
// 기본 타입이 기반 타입인 경우
type MyInt int
type MyString string
type Celsius float64

// 구조체 타입이 기반 타입인 경우
type Book struct {
    Title string
    Price int
}

// 기존 구조체를 기반으로 새 이름 부여
type TextBook Book
```

기반 타입의 규칙

#### 1. 동일한 기반 타입을 가져도 직접적인 할당을 허용하지 않는다

Go는 강력한 타입 안정성을 제공하기 위해 기반 타입이 동일한 서로 다른 네임드 타입 간의 변환은 명시적인 형변환만을 허락한다

```go
type MyInt int
type MyInt2 int

var mi MyInt = 1
var mi2 MyInt2 = 1

// 컴파일 오류, Go는 기반 타입이 동일해도 서로 다른 네임드 타입의 암시적 형변환을 허락하지 않는다
// mi = mi2

// 동일한 기반 타입인 경우 명시적인 형변환을 해줘야 한다
mi = MyInt(mi2)
```

#### 2. 기반 타입의 메서드를 상속하지 않는다

자바의 클래스 상속과 가장 큰 차이점 중 하나로, Go에서는 자바와 달리 새 타입이 기반 타입의 데이터 구조만 상속받고, 메서드를 상속받지 않는다 (기반 타입의 내부적인 메모리 레이아웃과 필드 구조만 그대로 사용한다)

`Book` 타입의 메서드가 정의되어 있더라도 `Book` 타입을 기반 타입으로 하는 `TextBook` 타입은 `Book` 타입의 메서드를 자동으로 가지지 않는다

`TextBook` 타입이 `Book` 타입의 메서드를 가지려면 `TextBook` 타입에 대해 해당 메서드를 별도로 정의하거나 `TextBook` 내부에 `Book`을 임베딩 해야 한다

#### 3. 인터페이스 만족 여부

Go는 인터페이스는 구조적 타이핑을 기반으로 하여 인터페이스에 정의된 메서드를 해당 타입이 모두 만족하는지 여부로 인터페이스 구현을 판단한다

네임드 타입은 기반 타입의 메서드를 상속받지 않기 때문에 기반 타입이 인터페이스를 만족하더라도 이와 상관없으며, 해당 네임드 타입이 인터페이스의 메서드를 모두 만족해야 한다

## 원시 타입

문자열형: `string`

불린형: `bool`

숫자형
- `int8`, `uint8` (`byte`), `int16`, `uint16`, `int32` (`rune`), `uint32`, `int64`, `uint64`, `int`, `uint`, `uintptr`
- `float32`, `float64`
- `complex64`, `complex128`

[내장 타입과 값 리터럴](./문법.md#내장-타입과-값-리터럴)


## 문자열 타입

표준 Go 컴파일러에서 문자열 타입의 내부 구조는 아래와 같이 정의될 것이다

문자열은 메모리 상에서 `byte` 타입(`uint8`)들이 순차적으로 저장되는 값을 감싸는 래퍼 값이다 (sequence wrapper)

```go
type _string struct {
    elements *byte  // 문자열 바이트 
    len      int    // 바이트수
}
```

문자열 타입의 기본 개념
- 문자열 리터럴은 boolean이나 숫자형 값처럼 상수로써 다뤄질 수 있다
- Go에서는 쌍따옴표나 백틱으로 문자열 리터럴을 나타낼 수 있다
- 문자열 타입의 기본 값은 공백 문자열이며 `""` 이나 ` ` 리터럴로 나타낼 수 있다
- 문자열 연결은 `+`, `+=` 연산자를 사용한다
- 모든 문자열 타입은 비교(`==`, `!=`, `>`, `<`, `>=`, `<=`) 연산자를 사용하여 비교할 수 있다
- 비교는 문자열을 이루는 바이트와 바이트끼리 이루어지며, 한 문자열이 다른 문자열의 접두사이면서 더 길면 그 문자열이 더 큰 문자열로 간주된다
- 문자열의 각 바이트는 주소 지정 불가능하며 불변이다

### 문자열 기본 연산

```go
const world = "world"
const hello = "hello"

// 문자열 연결
helloWorld := "hello" + " " + world
helloWorld += "!"
fmt.Println(helloWorld) // hello world!

// 문자열 비교
fmt.Println(hello == "hello") // true
fmt.Println(hello > helloWorld) // false

hello2 := helloWorld[:5] // 서브 스트링을 지원한다
fmt.Println(hello2)      // hello
fmt.Printf("%T \n", hello2[0]) // 문자열 인덱싱을 지원한다, uint8
fmt.Println(hello2[0]) // 104

// 문자열의 각 바이트는 주소 지정 불가능하며 불변이다
// 인덱싱이나 포인터를 통해 특정 바이트를 수정할 수 없다
// hello2[0] = 'H' 
// fmt.Println(&[hello]0)

// string 타입 자체엔 빌트인 함수를 제공하지 않는다
// 대신 strings 표준 패키지를 이용하여 문자열을 조작할 수 있다
fmt.Println(strings.HasPrefix(helloWorld, hello))
```

### 문자열 인코딩과 유니코드 코드 포인트

유니코드는 모든 종류의 인간 언어에 대한 각 문자를 유니크한 값으로 표준한 명세이다

이러한 유니크 값을 표현하는 유니코드의 기본 단위는 코드 포인트로, 각 코드 포인트가 특정 문자를 나타내며 어떤 문자는 여러 개의 코드 포인트로 이루어진다

Go에서 코드 포인트는 `rune` 리터럴로 표현된다. `rune`는 `int32` 타입에 대한 내장 별칭 타입이다

그리고 모든 문자열 리터럴은 UTF-8로 인코딩된 것으로 간주하는데 컴파일 타임에는 유효하지 않은 UTF-8 인코딩 문자열을 컴파일러가 감지하여 에러를 방지하지만, 런타임에는 이러한 문제를 방지할 수 없다

UTF-8 인코딩의 경우 각 코드 포인트는 하나 이상의 바이트(최대 4바이트)로 저장될 수 있다

영어 코드 포인트(영어 문자 하나)는 1바이트로 저장되지만 중국어 코드 포인트(중국어 문자 하나)는 3바이트로 저장된다


## 포인터

Go는 C 언어와 거의 비슷한 포인터를 지원한다

### 메모리 주소

포인터를 이해하기 전에 컴퓨터 메모리가 어떻게 구성되어 있는지 알아야 한다

메모리는 컴퓨터의 데이터를 일시적으로 저장하는 공간이다

이 메모리 공간은 작은 저장 단위들로 나뉘어 있는데 메모리의 특정 부분을 가리키기 위해 각 메모리 단위는 고유한 주소를 가진다

주소는 32비트 시스템에서는 4바이트, 64비트 시스템에서는 8바이트로 구성된다

4바이트 주소를 사용하면 최대 `2^32` 바이트(4GB) 크기의 메모리 공간을 가질 수 있고, 8바이트 주소를 사용하면 최대 `2^64` 바이트(16EB) 크기의 메모리 공간을 가질 수 있다

2^30 == 1GB

16EB (1EB == 1024PB, 1PB == 1024TB, 1TB == 1024GB)

메모리 주소는 음수를 가지지 않고 16진수로 표현된다 `0x13AE3782`

### 포인터 개념: 참조와 역참조

**일반적인 변수**는 **값을 직접 저장**한다

`var age = 30` 코드는 메모리 어딘가에 `age`라는 이름을 가진 공간이 할당되고, 이 곳에 값 `30`이 저장된다

변수 `age` 자체는 자신에게 할당된 특정 메모리 주소를 가진다

```text
0x1001: [ 30 ]  (age)
```

`fmt.Println(age)`를 호출하면 Go가 `age`가 가리키는 메모리 주소(`0x1001`)로 가서 저장되어 있는 값 `30`을 읽어와 출력한다

**포인터**는 일반적인 변수와 다르게 **값이 아닌 다른 변수의 메모리 주소를 저장**한다 -> 다른 값의 주소를 저장한다

정확히는 값이 저장된 해당 변수의 메모리 시작 주소를 저장한다

포인터의 값이 다른 변수의 메모리 주소이고 가리켜지는 변수가 특정 값을 저장하고 있다면, 포인터의 값은 해당 값의 주소를 저장한다고 볼 수 있다

이를 **참조(reference)** 라고 하며 포인터 변수에 의해 참조된 값은 적어도 하나의 참조를 가지게 된다

포인터 변수가 저장하고 있는 어떤 변수가 저장하고 있는 값에 접근하는 것을 **역참조(dereference)** 라고 한다

역참조는 **역참조 연산자(dereference operator)** 인 `*` (애스터리스크)를 포인터 변수 앞에 붙여 사용하면 포인터가 가리키는 메모리 주소에 저장된 값을 가져올 수 있다

또한 특정 변수가 자신 앞에 **주소 연산자인(address operator)** 인 `&` (앰퍼샌드)를 붙여 자신의 메모리의 주소(특정 값의 메모리 주소)를 나타낼 수 있다

이렇게 `&`로 자신의 주소를 나타낼 수 있는 값을 **주소 지정 가능한 값(Addressable Values)** 라고 하며, 포인터 변수에 의해 참조된 후 역참조를 통해 접근할 수 있다

Go에서 모든 변수가 주소 지정 가능한 값이 될 수 있지만 상수, 함수 호출, 명시적 형변환 결과는 주소 지정 가능한 값이 될 수 없다

요약 정리
- 변수: 값을 저장하는 메모리 공간에 붙여진 이름 (메모리 시작 주소)
- 포인터: 다른 변수의 메모리 주소를 값으로 저장하는 변수
- 참조: 다른 변수의 메모리 주소를 참조하는 상태
- 역참조(`*`): 포인터가 가진 주소로 가서 값에 접근하는 행위
- `&`: 변수의 메모리 주소, 포인터가 될 값

### Go의 포인터 타입

Go의 포인터 타입은 특정 타입의 메모리 주소를 가리킨다

`var p *int`: `int` 타입의 메모리 주소를 저장하는 `p`라는 포인터 변수를 선언한다

Go에서는 `*T`는 `T` 타입에 대한 메모리 주소를 저장하는 포인터를 의미한다

`p = &age`: `age` 변수의 메모리 주소를 `p` 포인터 변수에 할당한다

`&` (앰퍼샌드)는 **주소 연산자(address operator)** 라고 불리며 뒤에 오는 메모리 주소를 반환한다

이제 `p`는 `age`가 있는 곳의 메모리 주소 값을 가지고 있으며, `p`는 `age`를 가리키고(point to) 있다고 한다

```text
메모리     값            변수
0x1001: [ 30 ]       (변수 age)
0x2002: [ 0x1001 ]   (포인터 변수 p)
```

포인터 변수에 역참조 연산자 `*`(애스터리스크)를 붙이면 **`*p`** 역참조를 수행하여 포인터 변수가 가리키는 변수의 값에 접근할 수 있다

타입에 `*`를 붙이면 포인터를 의미하고, 포인터 변수에 `*`를 붙이면 역참조를 의미하므로 헷갈리지 말자

---

`*T` 형태의 타입은, T 타입의 값을 가리키는 포인터로 `type` 키워드를 사용하여 이름을 부여하지 않고 직접적으로 `*T` 형태로 선언하여 사용하는 **익명 포인터 타입(unamed pointer type)** 이다

일반적으로 사용하는 포인터 타입 표현 방식으로 변수 선언, 함수 매개변수 및 반환 타입 지정 등에 사용된다

`int`나 `string`처럼 그 자체로 특정 타입을 나타내는 리터럴과 같아서 **타입 리터럴**이라고 한다

`type` 키워드를 사용하여 `*T` 형태의 포인터 타입에 새로운 이름을 부여한 것을 **명명된 포인터 타입(named pointer type)** 이라고 한다

네임드 타입은 Go 타입 시스템에서 별개의 새로운 타입으로 간주된다

즉, `type MyPtr *int`의 `MyPtr`은 기본적으로 `*int`와 동일한 하부 타입을 가지지만 Go 컴파일러는 `MyPtr`과 `*int`를 서로 다른 타입으로 취급하기 때문에 명시적인 형변환 없이 할당할 수 없게 된다

```go
// int 타입을 가리키는 익명(unamed) 포인터 타입
*int   
// *int 타입을 가리키는 익명(unamed) 포인터 타입
**int  

// int를 타입을 가리키는 네임드(named) 포인터 타입
type Ptr *int 
// Ptr 타입을 가리키는 네임드(named) 포인터 타입
type PP *Ptr
```

`**int` 포인터 타입은 다른 `*int` 포인터 타입을 가리키는 포인터 타입으로 **포인터 래퍼 타입(pointer wrapper type)** 이라고 한다

이러한 포인터와 포인터 래퍼 타입을 **포인터 홀더 타입(pointer holder type)** 이라고 한다

**포인터 타입의 기본 값은 `nil`이고, `T` 타입을 기반으로 하는 포인터 타입은 타입 `T`에 대한 주소 값만 저장할 수 있다**

nil 포인터에 대한 역참조는 런타임 오류를 일으키게 된다

---

Go에서 포인터 값을 얻는 방법은 두 가지가 있다

#### 1. 빌트인 `new` 함수 사용

내장 함수인 `new`는 어떤 타입에 대한 값을 저장할 수 있는 메모리를 할당한다

`new(T)`는 타입 `T`에 대한 메모리를 할당한 후 타입 `T`의 기본 값으로 설정한 뒤 메모리 주소를 반환한다

반환된 주소 값은 타입 `*T`의 포인터의 값으로 간주된다

```go
// 타입 int에 대한 메모리 공간 할당 및 주소 반환
// var p *int
p := new(int)
println(p)    // p 참조값(포인터 p가 가리키는 메모리 주소 값)
println(*p)   // p 역참조값(int 기본 값 0)
```

#### 2. `&` 사용

주소 지정 가능한 값인 경우 변수 앞에 `&`를 붙여 자신의 주소를 포인터 변수에 할당할 수 있다

타입 `T`의 주소 지정 가능한 값 `v`는 `&t` 연산자를 사용하여 `t`의 주소를 포인터 값으로 사용할 수 있다

```go
t := 1      // 타입 int에 대한 값 t
p := &t     // 변수 t에 대한 메모리 주소 할당
println(p)  // p 참조값(변수 t의 메모리 주소)
println(*p) // p 역참조값(변수 t의 값 1)
```

### 역참조(*), & 활용

타입에 `*`를 붙이면(`*T`) 포인터를 의미하고, 포인터 변수에 `*`를 붙이면(`*pointer`) 역참조를 의미한다

```go
// var p *int
p := new(int)       // 메모리 할당

x := *p				// p의 역참조값(0) 복사
xp1, xp2 := &x, &x  // x 주소값 할당

// xp1 == xp2:  true
// xp1 == p:  false

xp3 := &*p   // &*p == &(*p) == p
// xp3 = p: true

*p = 100
// *p, *xp3: 100
// x, *xp1, *xp2: 0

// 역참조한 값의 타입
fmt.Printf("*p: %T, x: %T \n", *p, x)
// 포인터 타입
fmt.Printf("p: %T, xp1: %T \n", p, xp1)
```

### Go 포인터의 특징

Go 언어에는 사실 두 가지 포인터 타입이 존재한다

일반적으로 사용하는 포인터(위에서 설명한 포인터 타입)는 타입-세이프한 포인터이고 또 다른 한 가지는 `unsafe` 표준 패키지에서 제공하는 `unsafe.Pointer` 타입이다

Go는 가비지 컬렉터에 의해 관리되므로 C 언어의 포인터와 다르게 개발자가 수동으로 메모리를 할당 해제할 필요가 없다 -> C/C++에서 사람의 실수로 인해 발생하는 메모리 누수와 같은 포인터 관련 오류를 크게 줄여준다

Go의 포인터는 안전하게 사용될 수 있도록 C 언어의 포인터에 비해 몇 가지 제한사항을 가진다 (unsafe 표준 패키지를 사용하면 이러한 제약사항 없이 포인터를 사용할 수 있으나 권장되지 않는다)

#### 1. Go 포인터는 산술 연산을 지원하지 않는다

Go에서는 포인터 `p`에 대해 `p++`, `p-2`와 같은 산술 연산을 수행할 수 없다

`p`가 숫자형 값을 가리키고 있다면 `*p++`에 대해 Go 컴파일러는 `(*p)++`로 취급한다 (역참조 연산자 `*`가 산술 연산자보다 높은 우선순위를 가진다)

#### 2. 포인터의 값은 임의의 포인터 타입으로 변환될 수 없다

포인터의 값은 특정 타입의 인스턴스를 가리키는데, 이 때 메모리 시작 주소를 저장한다

포인터는 포인터 타입을 통해 메모리 시작 주소부터 어디까지 메모리를 참조해야 되는지 알 수 있는 것인데, 임의의 포인터 타입으로 변경해버리면 이를 알 수 없게 되어 엉뚱한 메모리 참조가 발생하게 된다

Go는 이러한 문제를 방지하고자 포인터 값을 임의의 포인터 타입으로 변환시키지 못하도록 막는다

대신 다음 두 가지 중 한 가지 조건에 만족한다면 포인터 타입 `T1`의 포인터 값이 다른 포인터 타입 `T2`로 변환할 수 있다

- 타입 `T1`과 타입 `T2`의 기반 타입이 동일해야 한다 (`T1`과 `T2`가 익명 타입이며 기반 타입이 동일한 경우 암시적 형변환도 가능하다)
- 타입 `T1`과 타입 `T2`가 익명 포인터 타입이면서 기반 타입이 동일해야 한다

기반 타입이 동일하면 메모리 참조 범위가 동일하므로 포인터가 정상적으로 동작할 수 있기 때문에 형변환이 가능해진다

반대로 기반 타입이 동일하지 않으면 암시적/명시적 형변환이 모두 되지 않는다

```go
package main

import "fmt"

type MyInt int64
type Ta *int64
type Tb *MyInt

func main() {

	var x int64 = 100
	var y MyInt = 200

	// 포인터 p0의 값은 Ta 포인터 타입과 기반 타입(*int64)이 동일하여 암시적 형변환이 가능하다
	var p0 *int64 = &x
	var p1 Ta = p0

	// 포인터 p2의 값은 p3 포인터 타입과 기반 타입(*MyInt)이 동일하여 암시적 형변환이 가능하다
	var p2 *MyInt = &y
	var p3 Tb = p2

	// 포인터 p2의 값(*MyInt)은 p4 포인터 타입(*Int64)과 타입이 다르기 때문에 암시적 형변환이 불가능하다 (컴파일 오류)
	// var p4 *int64 = p2

	// 대신 명시적 형변환을 통해 *MyInt 포인터를 *int64 포인터로 변환할 수 있다 (두 포인터가 동일한 기반 타입인 int64를 가리킨다는 것을 Go 컴파일러에게 알려준다)
	var p4 *int64 = (*int64)(p2)

	// p5(Tb)와 p1(Ta)은 타입이 달라 암시적/명시적 형변환이 불가능하다
	// var p5 Tb = p1
	// var p5 Tb = (Tb) (p1)

	// 대신 아래와 같이 세 단계의 명시적 형변환을 하면 가능하다
	var p5 Tb = Tb((*MyInt)((*int64)(p1)))

	// p0: *int64 
    // p1: main.Ta 
    // p2: *main.MyInt 
    // p3: main.Tb 
    // p4: *int64 
    // p5: main.Tb 
}
```


## 구조체

Go는 C와 동일하게 구조체를 지원한다

`struct` 키워드를 시작으로 감싸진 `{}` 괄호 안에 필드(멤버 변수)를 순서대로 선언하여 구조체 리터럴을 정의할 수 있다 (필드 생략 가능)

각 필드는 필드 이름과 타입을 포함하여 선언될 수 있다

```go
struct {
    title string
    author string
    pages int
}

struct {
    // 동일한 타입은 한 줄로 선언할 수 있다
    title, author string
    pages int
}
```

구조체 타입의 크기는 모든 필드 타입과 일정 패딩 바이트 합으로 정해진다 (필드 태그는 크기에 영향을 주지 않는다)

필드를 하나도 가지지 않는 구조체 타입의 크기는 0이 된다

구조체는 각 필드 옆에 해당 필드에 대한 메타데이터를 제공할 수 있는 필드 태그를 붙일 수도 있다 (런타임에 리플렉션으로 필드 태그 정보에 접근할 수 있다)

일반적으로 JSON, XML, YAML 등 다른 데이터 형식으로 구조체를 마샬링(인코딩), 언마샬링(디코딩)할 때 구조헤 필드의 이름과 외부 데이터 형식의 필드 이름을 매핑하는 규칙을 정의하는데 사용된다

```go
struct {
    Title string  `json: "title" myfmt:"s1"`
    Author string `json: "author"`
    Pages int     `json: "pages"`
}
```

공개된 구조체 필드만이 `encoding/json` 등의 패키지를 통해 처리되거나 임포트한 다른 패키지에서 보여져서 사용될 수 있다 -> 공개되지 않은 구조체 필드는 private 또는 protected처럼 사용된다

### 구조체 초기화, 구조체 포인터

구조체를 `T{...}` 형태로 초기화할 수 있는데 이러한 형태를 **복합 리터럴(composite literal)** 이라고 한다

`T`는 타입 리터럴이거나 타입의 이름이어야 하고, 복합 리터럴은 구조체 타입 뿐만 아니라 컨테이너 타입들(map, 배열 등)에서 사용된다

아래와 같이 구조체를 초기화할 때 구조체에 선언된 필드 순서에 따라 값을 지정하거나 필드의 이름과 함께 지정할 수 있다 (필드 이름을 지정하면 필드 순서를 무시할 수 있다)

또한 값 지정을 부분/전체적으로 생략할 수 있는데, 이 경우 해당 타입의 기본 값으로 대체된다

```go
package main

type Book struct {
    title   string
    pages   int
    price   int
}

func main() {

    // 구조체에 선언된 필드의 순서를 따르는 복합 리터럴
    goBook := Book{"golang", 100, 10_000}
    
    // 필드 이름과 매핑하여 복합 리터럴
    javaBook := Book{title: "java", pages: 200, price: 20_000}

    // 일부 필드만 이름과 매핑한 복합 리터럴 (생략한 필드는 기본값으로 대체됨)
    unknownBook := Book{title: "unknown"}

    // 모든 값을 생략한 복합 리터럴 (기본값으로 대체됨)
    emptyBook := Book{}

}
```

### 구조체 값 복사

구조체 값을 다른 구조체 값에 할당하면 해당 구조체의 필드를 하나씩 복사하는 것과 같은 결과를 가진다

이 때 두 구조체 값은 서로의 구조체 타입이 동일하거나 서로 가진 구조체 값의 기반 타입이 동일해야 하며 두 타입 중 적어도 하나는 익명 타입이어야 한다

```go
book1 := Book{price: 10_000}
book2 := Book{"go", 100, 0}

book2 = book1

// 아래 코드는 위 코드와 동일하다
book2.title = book1.title
book2.pages = book1.pages
book2.price = book1.price
```

### 필드 주소 지정  

주소 지정 가능한 구조체의 필드는 주소 지정이 가능하며, 주소 지정이 되지 않는 구조체의 필드는 마찬가지로 주소 지정이 불가능하며 수정될 수 없다

모든 복합 리터럴은 주소 지정 불가능하다 (구조체 복합 리터럴)

```go
package main

func main() {

    type Book struct {
        pages int
    }

    // book을 통해 구조체의 주소에 접근할 수 있다
    var book = Book{pages: 100}
	println("book pages:", book.pages)
    b := &book.pages // . 연산자는 & 연산자보다 우선순위가 높다
    *b = 200
	println("book pages:", book.pages)

    // 복합 리터럴은 주소 지정할 수 없으며 수정될 수도 없다
    // Book{}.pages = 100
    // b = &(Book{}.pages)

    // syntatic sugar를 사용하면 복합 리터럴을 주소 지정할 수 있다
    // 아래는 tmp := Book{100}; book2 := &tmp 와 동일하다
    book2 := &Book{100}
    println("book2 pages:", book2.pages)
}
```

### 필드 선택자에 대한 암묵적 역참조

아래와 같이 값을 받는 변수가 구조체 필드 선택자라면 암묵적으로 역참조가 발생한다

즉, `(*struct_ptr).field`는 `struct_ptr.field`처럼 쓰일 수 있다

```go
package main

func main() {

    type Book struct {
        pages int
    }

    book1 := &Book{100}
    book2 := new(Book)

    book2.pages = book1.pages

    // 아래 코드는 위 코드와 동일하다
    // 값을 받는 변수가 구조체 필드 선택자라면 암묵적으로 역참조가 발생한다
    // (*book2).pages = (*book1).pages

}
```

### 구조체 값 비교와 서로 다른 구조체의 값 변환

구조체 간 값을 비교하려면 각 필드의 값이 비교 가능해야 하며 (`_` 포함), 각 값이 동일한 타입/기반 타입으로써 서로에게 할당해야 하고 비교할 수 있어야 한다

같은 타입의 두 구조체 값(필드)을 비교할 때 두 값이 동일한 경우에만 비교가 진행되며 동일하지 않은 경우 비교가 중단된다 (`_` 이름의 필드는 비교 대상에서 제외된다)

[서로 다른 구조체의 값 변환 참고](https://go101.org/article/struct.html)


## 함수

Go에서 함수는 1급 시민으로 취급되어 다른 일반적인 데이터 타입(정수, 문자열 등)과 동일한 수준으로 다룰 수 있다 

변수 할당, 함수 인자 전달, 함수 반환 값, 자료 구조 저장 등에 함수를 값처럼 사용할 수 있다

다만 함수 타입은 맵이나 슬라이스와 마찬가지로 비교할 수 없는 타입이므로 맵의 키 타입으로 사용될 수 없다

### 함수 타입 리터럴

함수 타입의 리터럴은 `func` 키워드와 함께 함수 시그니처 리터럴로 구성된다

함수 시그니처 리터럴은 **파라미터 타입 리스트** 와 **반환 결과 타입 리스트** 로 이루어진다

```go
// 두 함수 리터럴은 동일하다
func (a int, b string, c string) (x int, y int, z bool)
func (a int, b, c string) (x, y int, z bool)

// 함수 리터럴에서 파라미터와 반환 결과 타입 리스트에 정의된 이름은 리터럴 값에 영향을 주지 않는다
// 또한 이름은 모두 존재하거나 모두 생략해야 한다 (파라미터, 반환 결과 각각)
// 아래의 함수 리터럴들은 위의 것들과 동일하다
func (x int, y, z string) (a, b int, c bool)
func (_ int, _, _ string) (_, _ int, _ bool)
func (int, string, string) (int, int, bool)
func (a int, b string, c string) (int, int, bool)
```

반환 값이 없는 경우 리터럴에서 생략할 수 있으며, 하나인 경우에는 괄호를 생략할 수 있다

파라미터 리스트는 파라미터가 없다고 해도 생략할 수 없다

```go
// 아래 함수 리터럴은 모두 동일하다
func () (x int)
func () (int)
func () int

// 두 함수 리터럴은 동일하다
func (a int, b string) ()
func (a int, b string)
```

함수의 파라미터 리스트의 맨 마지막에 가변 파라미터를 둘 수 있다

가변 파라미터는 `slice` 타입이며 구체적인 타입을 정의한 뒤 앞에 `...`을 붙여 나타낼 수 있다

가변 파라미터가 있는 함수를 가변 함수 타입이라고 하며, 가변 함수 타입은 일반 함수 타입과 동일하지 않다

```go
func (values ...int64) (sum int64)
func (sep string, tokens ...string) string
```

### 함수 프로토타입

함수 프로토타입은 함수 이름과 함수 리터럴로 이루어진다

즉, 함수의 본문 부분을 제외한 나머지를 함수 프로토타입이라고 한다

-> 함수 선언은 함수 프로토타입과 함수 본문으로 이루어진다는 것을 알 수 있다

```go
func Double(n int) (result int)
```

### 표현식으로 함수 호출 사용하기

단일 값을 반환하는 함수 호출은 하나의 값으로써 사용될 수 있다

다른 함수의 인자로 전달되거나 다른 표현식이나 함수의 값으로써 사용된다

다중 값을 반환하는 함수 호출 시 반환 값을 무시할 수 없다면, 두 가지 경우에 다중 값 표현식(multi-value expression)으로 사용될 수 있다
- 값을 할당하는 부분(source value)로써 사용되는 경우 (대신 다른 할당값과 함께 사용될 수 없다)
- 다른 함수의 인자로 사용되는 경우 (대신 다른 인자와 함께 인자로 사용될 수 없다)

```go
func HalfAndnegative(n int) (int, int) {
	return n/2, -n
}

func AddSub(a, b int) (int, int) {
	return a+b, a-b
}

func Dummy(values ...int) {}

func main() {

    fmt.Println(AddSub(HalfAndnegative(6)))
    fmt.Println(AddSub(AddSub(AddSub(7, 5))))
    fmt.Println(AddSub(HalfAndnegative(6)))
    Dummy(HalfAndnegative(6))
    _, _ = AddSub(7, 5)

    // 다중 값을 반환하는 함수는 다른 할당값(source value)과 함께 값을 할당할 수 없다
    // _, _, _ = 6, AddSub(7, 5)

    // 다중 값을 반환하는 함수는 다른 인자와 함께 인자로 전달될 수 없다
    // Dummy(AddSub(7, 5), 9)
    // Dummy(AddSub(7, 5), HalfAndnegative(6))
}
```

### 가변 함수 호출

가변 함수를 호출할 때 가변 인자를 전달하는 방법은 두 가지이다

#### 1. 한 개의 슬라이스만 전달하는 방법

인자로 전달하는 슬라이스는 파라미터의 타입에 할당 가능해야 하고, 전달하는 슬라이스 뒤에 `...`를 붙여야 한다

Go는 직접 값 부분(Direct Part)만 할당(복사)하므로 슬라이스가 가리키고 있는 실제 데이터 메모리는 두 변수 모두 공유한다

#### 2. 0개 또는 그 이상의 인자를 전달하는 방법

이 역시 파라미터의 타입에 할당 가능해야 한다

직접 값 부분을 복사하므로 파라미터의 타입 `[]T`의 요소에 전달한 값들을 새로 할당한다

```go
func sum(values ...int64) (sum int64) {
	sum = 0
	for _, v := range values {
		sum += v
	}
	return
}

func main() {

	a0 := sum()
	a1 := sum(2)
	a2 := sum(2, 3, 5)

	// 위의 세 개 라인은 아래의 각각 라인과 동일하다
	b0 := sum([]int64{}...)
	b1 := sum([]int64{2}...)
	b2 := sum([]int64{2, 3, 5}...)

	fmt.Println(a0, a1, a2)
	fmt.Println(b0, b1, b2)

}
```

### 함수 선언과 호출에 관한 정보

#### 1. 함수 이름은 중복될 수 있다

일반적으로 동일한 코드 패키지(디렉토리)내에서 함수 이름은 중복될 수 없지만 두 가지 예외가 존재한다

`func ()` 함수 타입과 `init` 이름을 가진 함수는 여러 번 선언될 수 있다

함수 이름이 `_` (공백 식별자)인 경우 여러 번 선언될 수 있다 (선언된 함수는 절대 호출되지 않는다)

```go
var a int

// 소스 코드 파일의 init 함수는 자동으로 호출된다 (다른 패키지에서 임포트했을 때에도)
// init 이름과 `func ()` 타입의 함수는 여러번 선언될 수 있다

func init() {
	fmt.Println("hello init function")
}

func init() {
	fmt.Println("hello another init function")
	a = 1
}


func main() {
	fmt.Println(a) // 1
}
```

#### 2. 특정 함수 호출은 컴파일 시점에 평가된다

대부분 함수 호출은 런타임에 평가되지만 `unsafe` 표준 패키지의 함수는 항상 컴파일 타임에 평가된다

`len`과 `cap` 같은 내장 함수도 컴파일 타임에 평가될 수 있다 (인자에 따라 런타임에 평가될 수도 있다)

컴파일 시점에 평가된 함수 호출의 값은 상수로 할당될 수 있다

#### 3. 모든 함수 인자는 복사에 의해 전달된다

Go는 복사에 의해 함수 인자를 전달하는데, 이 때 얕은 복사를 수행하여 값 부분(Direct Part)만 복사된다

맵이나 슬라이스 같이 하부 값 부분(Underlying Part)은 복사되지 않기 때문에 인자와 파라미터가 동일한 데이터를 바라보게 된다

#### 4. 커스텀 함수 호출의 결과값은 무시할 수 있으나 내장 함수는 무시할 수 없다

개발자가 선언한 함수 호출의 결과값은 모두 무시할 수 있다

`recover`과 `copy` 함수를 제외한 다른 내장 함수의 호출 결과값은 무시할 수 없다

대신 `_`에 결과값을 할당하여 무시할 수 있다 `_ = len(a)`

참고로 결과값을 무시할 수 없는 함수는 지연된 함수(deferred function)나 고루틴 호출로 사용될 수 없다

#### 5. 함수 값

함수의 기본 값은 `nil` 식별자로 표현된다

개발자가 하나의 커스텀 함수를 선언하면 실제로는 불변 함수 값도 같이 선언된다

이는 Go가 함수, 슬라이스, 맵 같은 특정 타입에 대해 메모리 상에서 헤더와 실제 데이터가 위치한 메모리를 분리했기 때문이다

함수를 선언하면 하부 값 부분(Underlying Part)에 함수 객체가 생성되는데 이를 여러 변수가 참조할 수 있다

함수 값은 함수의 이름으로 식별되며, 함수 값의 타입은 함수 리터럴(이름 제외)로 표현된다

내장 함수는 값으로써 다룰 수 없다

```go
func add(n int) int {
	return n + n
}

// f 타입: `func(int) int`
func apply(n int, f func(int) int) int {
	return f(n)  
}

func main() {

	fmt.Printf("%T\n", add) // func(int) int

	// add = nil // 선언된 함수는 불변이므로 런타임에 수정될 수 없다

	var f func(n int) int // 기본값: nil
	
	f = add // f와 add는 동일함 함수 객체를 참조한다
	g := apply // g와 apply는 동일한 함수 객체를 참조한다

	fmt.Printf("%T\n", f) // func(int) int
	fmt.Printf("%T\n", g) // func(int, func(int) int) int

	fmt.Println(f(9))         // 18
	fmt.Println(g(6, add))	  // 12
	fmt.Println(apply(6, f))  // 12
}
```


### 내장 함수

Go에서 제공하는 내장 함수는 `builtin`과 `unsafe` 패키지에 명시되어 있다

### 함수 타입 정의

아래와 같이 함수 타입을 정의하고 여러 번 재사용할 수 있다

```go
// 단순 계산 named type 함수
type calculator func(a, b int) int

// 메시지 출력 named type 함수 
type messagePrinter func(msg string)

// 비동기 작업을 완료했을 때 호출될 콜백 함수를 위한 named type 함수
type asyncCallback func(result string, err error)

// 로직을 처리하고 두 개의 값을 반환하는 named type  함수
type processor func(data []byte) (processedData string, checksum int, err error)


func main() {

	// calculator 타입의 변수 add 선언 및 익명 함수(함수 리터럴) 할당
	var add calculator = func(a, b int) int {
		return a + b
	}

	// calculator 타입의 변수 subtract 선언 및 익명 함수 할당
	// 위 코드처럼 함수 이름을 변수명 옆에 붙이거나 함수 리터럴을 함수 이름으로 감싸서 함수를 만들 수 있다
	subtract := calculator(func(a, b int) int {
		return a - b
	})

	fmt.Println(add(5, 3))		// 8
	fmt.Println(subtract(5, 3)) // 2

	var printer messagePrinter = func(name string) {
		fmt.Println("hello", name)
	}

	printer("hansanhha")  // hello hansanhha

}
```

## 컨테이너: 배열, 슬라이스, 맵

### 공통 사항

#### 컨테이너 리터럴 (unamed)
- N: 크기(양수), T: 타입, K: 맵 키 타입
- 배열 리터럴: `[N]T`
- 슬라이스 리터럴: `[]T`
- 맵 리터럴 `map[K]T` (키, 값)

#### 초기화
- 컨테이너 선언 시 초기 값들을 지정하지 않으면 요소 타입의 기본 값으로 메모리를 할당한다
- 이 때, 기본값으로 초기화하거나 nil 갑승로 초기화할 수 있다
- `[]T{}`: `T` 타입의 기본값으로 슬라이스 초기화
- `[]T(nil)`: `nil` 값으로 슬라이스 초기화

#### 컨테이너 비교
- 맵과 슬라이스는 비교할 수 없는 타입이다 -> 맵과 슬라이스는 맵의 키로 사용될 수 없다
- 비교할 수 없는 값이더라도 `nil`과 비교하여 슬라이스나 맵 값이 0값인지 여부를 확인할 수 있다

```go
// 변수만 선언한다 (메모리 할당 X)
var a [16]byte
var s []int
var m map[string]int

fmt.Println(a == a) // true
fmt.Println(m == nil) // true
fmt.Println(s == nil) // true

// 컨테이너 리터럴과 nil 값은 같지 않다
fmt.Println(nil == map[string]int{}) // false
fmt.Println(nil == []int{}) // false

// 컴파일 오류, 맵과 슬라이스는 비교할 수 없는 타입이다
// _ = m == m
// _ = m == map[string]int(nil)
// _ s == s
// _ s == []int(nil)
```

#### 컨테이너 길이(length)와 용량(capacity) 속성
- 내장 함수인 len과 cap을 통해 컨테이너 길이와 용량을 확인할 수 있다
- 배열의 길이와 용량은 동일하며 절대 변경될 수 없다
- 맵의 경우 용량이 무제한이므로 cap 함수는 맵 값에 적용되지 않는다
- 슬라이스의 용량은 길이와 같거나 더 클 수 있다 -> 런타임에 길이와 용량이 변경되므로 동적 배열로 볼 수 있다

```go
var a [5]int
fmt.Println(len(a), cap(a)) // 5 5 

var s []int
fmt.Println(len(s), cap(s)) // 0 0

s, s2 := []int{2, 3, 5}, []bool{}
fmt.Println(len(s), cap(s))   // 3 3
fmt.Println(len(s2), cap(s2)) // 0 0

var m map[int]bool
fmt.Println(len(m)) // 0
m, m2 := map[int]bool{1: true, 0: false}, map[int]int{}
fmt.Println(len(m)) // 2
fmt.Println(len(m2)) // 0
```

#### 컨테이너 요소 접근 및 수정
- `c[k]`로 컨테이너의 요소에 접근할 수 있다 (`c`: 컨테이너, `k`: 키)
- 배열, 슬라이스는 k의 값이 인덱스로 사용되고, 맵은 특정 키를 나타낸다
- 배열 인덱스 값은 배열의 크기보다 작아야 한다
- 인덱스 값이 상수가 아닌 경우 0보다 크거나 같아야 하며 `len(v)`보다 작아야 한다
- 슬라이스가 `nil`인 경우 인덱싱을 하면 런타임 오류가 발생한다
- 맵의 키가 비교 불가능하거나, 맵이 `nil`일 때 요소를 할당하기 위한 접근(destination value)이라면 런타임 오류가 발생한다
- 반대로 맵의 요소를 가져오는 접근이라면 맵과 키가 `nil`이어도 런타임 오류가 발생하지 않는다
- 대신 맵 `v` 값의 기본값을 반환하며, 맵은 항상 요소를 접근에 대한 반환 값으로 해당 요소가 포함 여부도 함께 반환한다 (다중 값 반환)

```go
a := [3]int{-1, 0, 1}
s := []bool{true, false}
m := map[string]int{"abc": 123, "xyz": 789}

fmt.Println(a[2], s[1], m["abc"])

a[2], s[1], m["abc"] = 999, true, 567
fmt.Println(a[2], s[1], m["abc"])

n, present := m["hello"]
fmt.Println(n, present, m["hello"])

n, present = m["abc"]
fmt.Println(n, present, m["abc"])

// 컴파일 오류
// 배열 길이보다 더 큰 인덱스를 사용할 수 없다 (상수값)
// 인덱스에 음수를 사용할 수 없다
// _ = a[3]
// _ = s[-1]

// 런타임 오류
// 변수를 사용하여 인덱싱했을 때 인덱스 범위를 벗어나면 런타임 오류가 발생한다
// 존재하지 않는 맵의 키에 값을 할당하려하면 런타임 오류가 발생한다
_ = a[n]
_ = s[n]
m["hello"] = 555
```

#### 컨테이너 요소 삽입, 삭제
- 맵 엔트리 삽입: `m[k] = e`(맵 수정과 동일하다) 맵의 키가 없으면 삽입, 있으면 수정 연산 수행
- 맵 엔트리 삭제: `delete(m, k)` 맵에 주어진 키가 없다면 아무 연산을 수행하지 않는다 (에러 발생 X)
- 배열 요소 삽입/삭제: 불가능, 요소 수정만 가능
- 슬라이스 요소 삽입: `append` 함수로 여러 개 요소 삽입 가능
- 슬라이스 요소 삭제: 삭제 내장 함수를 제공하지 않음. 서브 슬라이스 활용 필요


#### 컨테이너 할당
- 맵을 다른 맵에 할당하면 모든 요소를 공유한다
- 슬라이스를 다른 슬라이스에 할당하면 모든 요소를 공유한다
- 다만 한 슬라이스가 길이와 용량을 변경해도 다른 슬라이스에 반영되지 않는다
- 배열을 다른 배열에 할당하면 모든 요소가 복사되고, 두 배열은 어느 요소도 공유하지 않는다

```go
m0 := map[int]int{0:7, 1:8, 2:9}
m1 := m0
m1[0] = 2
fmt.Println(m0, m1) // map[0:2 1:8 2:9] map[0:2 1:8 2:9]

s0 := []int{7,8,9}
s1 := s0
s1[0] = 2
fmt.Println(s0, s1) // [2 8 9] [2 8 9]

a0 := [...]int{7,8,9}
a1 := a0
a1[0] = 2
fmt.Println(a0, a1)	// [7 8 9] [2 8 9]
```

#### 동기화
- 컨테이너 연산은 동기화되지 않는다
- 여러 고루틴이 하나의 컨테이너를 읽는 것은 허용된다
- 동기화되지 않은 채로 여러 고루틴이 하나의 컨테이너를 수정하면 경쟁 조건 등 런타임 오류를 발생시킨다

### 배열

```go
type Book struct {
	title string
	pages int
}

const Size = 32

a := [2]string{"hello", "golang"}

// 모든 요소가 int 타입의 기본 값으로 초기화된다
// 상수값만 배열의 크기로 지정할 수 있다
b := [Size]int{}

// 중첩된 복합 리터럴을 포함하는 경우 아래와 같이 타입을 생략하여 선언할 수 있다
c := [2]Book{
		{title: "gobook", pages: 10}, 
		{title: "example", pages: 20},
	}

d := [16][]byte{} // 배열 요소의 타입: []byte

// 배열과 슬라이스는 인덱스를 사용해서 초기화할 수 있다
e := [4]bool{0: false, 1: true, 2: true, 3: false}

// `...`: 초기화 시 길이를 컴파일러가 추론할 수 있게 한다
f := [...]bool{false, true, false, false}
```

### 슬라이스

```go
a := []int64{1,2,3,4,5,6,7,8,9}
b := []map[string]int{} // 슬라이스 요소 타입: map[string]int

// 슬라이스 요소 타입: *int
// 포인터 타입은 nil 값으로 초기화된다
c := []*int{} 

// 배열과 슬라이스는 인덱스를 사용해서 초기화할 수 있다
d := []string{2: "fallthrough", 1: "continue", 0: "break"}

// nil 값으로 초기화
e := []string(nil)

// 중첩된 복합 리터럴을 포함하는 경우 아래와 같이 타입을 생략하여 선언할 수 있다
f := []*[4]byte{
    &[4]byte{'P', 'N', 'G', ' '},
    &[4]byte{'G', 'I', 'F', ' '},
    &[4]byte{'J', 'P', 'E', 'G'},
}

f2 := []*[4]byte{
    {'P', 'N', 'G', ' '},
	{'G', 'I', 'F', ' '},
	{'J', 'P', 'E', 'G'},
}
```

#### 슬라이스 요소 추가/삭제

슬라이스는 `len`과 `cap` 속성으로 자신의 용량을 관리한다

`append` 내장 함수로 슬라이스의 요소를 추가할 수 있다

`append(slice []Type, elems ...Type)` 함수의 첫 번째 파라미터는 요소를 추가할 대상 슬라이스이고, 두 번째 파라미터는 가변 파라미터로 두 가지 방법으로 전달할 수 있다
- 0개 또는 하나 이상의 요소 전달 `append(s, 1,2,3,4)`
- 하나의 슬라이스 전달 `append(s, s...)` (이 때, 뒤에 `...`를 꼭 붙여야 하며 두 번째 인자가 동일한 첫 번째 인자와 동일한 타입일 필요는 없으나 요소 타입은 같아야 한다)

`append`함수는 새로 추가된 요소의 개수가 슬라이스의 남은 슬롯 개수보다 많다면 새로운 메모리를 할당하고 기존의 요소를 모두 복사한 뒤, 새로 추가된 요소를 삽입하여 새로운 슬라이스를 만든다

기존 슬라이스와 새 슬라이스는 서로 다른 메모리 세그먼트를 점유하기 때문에 어떤 요소도 공유하지 않는다

슬롯 개수가 충분하다면 기존 슬라이스에 요소를 삽입한 뒤 슬라이스를 반환한다

반환된 슬라이스와 기존 슬라이스는 동일한 메모리 세그먼트를 바라보고 모든 요소를 공유한다

즉, `append` 함수는 기존 슬라이스를 수정하지 않기 때문에 새로운 요소를 추가해도 기존 슬라이스를 참조하는 변수로 데이터에 접근하면 기존 데이터만 볼 수 있다

`append` 함수에서 반환한 슬라이스를 통해서 새로 할당된 데이터에 접근할 수 있다

```go
fmt.Printf("\n\n슬라이스 요소 추가 삭제\n")
y0 := []int{2,3,4}
fmt.Println(y0, cap(y0)) // [2 3 4] 3

y1 := append(y0, 5)      // append(y0, []int{5}...)와 동일
fmt.Println(y0, cap(y0)) // [2 3 4] 3
fmt.Println(y1, cap(y1)) // [2 3 4 5] 6

y2 := append(y1, 6,7)    // append(y0, []int{6, 7}...)와 동일
fmt.Println(y2, cap(y2)) // [2 3 4 5 6 7] 6

y3 := append(y0)		 // y3 := y0
fmt.Println(y3, cap(y3)) // [2 3 4] 3

y4 := append(y0, y0...)  // append(y0, y0[0], y0[1], y0[2])와 동일
fmt.Println(y4, cap(y4)) // [2 3 4 2 3 4] 6

y0[0], y1[0] = 100, 200
fmt.Println(y2[0], y3[0], y4[0]) // 200 100 2
```

#### 서브 슬라이스

슬라이스나 배열을 새로 슬라이스해서 파생 슬라이스를 만들 수 있다 (서브 슬라이스 또는 리슬라이싱이라고 함)

파생된 슬라이스는 기존 슬라이스나 배열과 동일한 메모리 세그먼트를 공유하므로 같은 요소를 바라본다

서브 슬라이스를 하는 방법은 아래와 같이 배열 또는 슬라이스를 기반으로 서브 슬라이스 표현식을 사용하면 된다

`nil` 슬라이스를 서브 슬라이스한 경우 파생 슬라이스 역시 `nil` 슬라이스가 된다

파생된 슬라이스의 길이는 `high -low`와 같고, 용량은 `max - low`와 같다

```go
// baseContainer: array or slice
// 0 <= low <= high <= max <= cap(baseContainer)
baseContainer[low : high] // two-index form, baseContainer[low : high: cap(baseContainer)]
baseContainer[low : high : max] // three-index form
```

서브 슬라이스의 low와 high를 생략할 수 있는 기준
- `low` 인덱스가 0인 경우 생략 가능
- `high` 값이 `len(baseContainer)`와 동일한 경우 two-index 형식에서만 생략 가능
- three-index 형식에서는 `max` 값을 절대 생략할 수 없다

```go
a := [...]int{0, 1, 2, 3, 4, 5, 6}

s0 := a[:]      // so := [0:7:7]    [0 1 2 3 10 7 6]
s1 := s0[:]     // s1 := s0         [0 1 2 3 10 7 6]
s2 := s1[1:3]   // s2 := a[1:3]     [1 2]
s3 := s1[3:]	// s3 := s1[3:7]    [3 10 7 6]
s4 := s0[3:5]   // s4 := s0[3:5:7]  [3 10]
s5 := s4[:2:2]  // s5 := s0[3:5:5]  [3 10]
s6 := append(s4, 7) // [3 10 7]
s7 := append(s5, 8) // [3 4 8]
s8 := append(s7, 9) // [3 4 8 9]
s3[1] = 10
```

#### 슬라이스 -> 배열 형변환

```go
var x = []int{0, 1, 2, 3}
var y = [4]int(x[:]) // 형 변환

fmt.Println(x) // [0 1 2 3]
fmt.Println(y) // [0 1 2 3]

x[2] = 10

fmt.Println(x) // [0 1 10 3]
fmt.Println(y) // [0 1 2 3]

// 형변환 시 배열 크기가 슬라이스 크기보다 큰 경우 런타임 오류가 발생한다
// _ = [3]int(x[:2])
```



### 맵

```go
a := map[string]int{"C": 1972, "Python": 1991, "Go": 2009}
b := map[int]bool{}

// 맵 요소의 값 타입: [6]string (배열)
c := map[int16][6]string{}

// 맵 요소의 값 타입: []string (슬라이스)
d := map[bool][]string{}

// 맵 요소의 키 타입: 구조체, 값 타입: *int8
e := map[struct{x int}]*int8{}

// 컴파일 오류
// 맵 리터럴의 엔트리 키는 생략될 수 없으며 상수만 사용할 수 있다
// var i = 1
// f := map[string]int{i: 100}
```

#### 맵 엔트리 추가/삭제/수정

```go
// 맵 엔트리 추가/삭제/수정
fmt.Printf("\n\n맵 엔트리 추가 삭제\n")
z := map[string]int{"Go": 2007}
z["C"] = 1972     // 삽입
z["Java"] = 1995  // 삽입
fmt.Println(z)    // map[C:1972 Go:2007 Java:1995]

z["Go"] = 2009    // 수정
delete(z, "Java") // 삭제
fmt.Println(z)    // map[C:1972 Go:2009]
```

### 컨테이너 초기화와 동시에 주소 할당하기

컨테이너 리터럴 `T{...}`에 주소 연산자 `&`를 붙이면 컨테이너를 초기화하는 동시에 주소를 포인터 변수에 할당할 수 있다

```go
pm := &map[string]int{"C": 1972, "Go": 2009}
ps := &[]string{"break", "continue"}
pa := &[...]bool{false, true, true, false}

fmt.Printf("%T\n", pm) // *map[string]int
fmt.Printf("%T\n", ps) // *[]string
fmt.Printf("%T\n", pa) // *[4]bool
```

### 내장함수: `make`, `new`, `copy`

`make` 함수로 맵이나 슬라이스를 생성할 수 있다 (채널도 생성 가능)

`make` 함수는 슬라이스의 요소 타입의 기본 값으로 모든 요소를 초기화한다

```go
// 빈 맵 생성
make(M, n)  // n 길이만큼 메모리 할당
make(M)     // 작은 길이 메모리 할당(컴파일러에 따라 다름)

// 빈 슬라이스 생성
// 두 값이 동일할 필요는 없지만 길이는 용량보다 클 수 없다
make(S, length, capacity)
make(S, length) // 길이와 용량이 같은 슬라이스 생성
```

```go
fmt.Println(make(map[string]int)) // map[]

m := make(map[string]int, 3)
fmt.Println(m, len(m)) // map[] 0

m["C"] = 1972
m["Go"] = 2009
fmt.Println(m, len(m)) // map[C:1972 Go:2009] 2

s := make([]int, 3, 5)
fmt.Println(s, len(s), cap(s)) // [0 0 0] 3 5

s = make([]int, 2)
fmt.Println(s, len(s), cap(s)) // [0 0] 2 2
```

`new` 함수를 이용하면  어떤 타입이든 값을 할당(해당 타입의 기본값)하고 할당된 값을 참조하는 포인터를 얻을 수 있다

컨테이너 타입은 복합 리터럴을 사용하여 초기화할 수 있기 때문에 컨테이너 타입 초기화 시에는 일반적으로 많이 사용되지 않는다

```go
x := *new(map[string]int) 	// x map[string]int
fmt.Println(x == nil)	  	// true

y := *new([]int)		  	// var y []int
fmt.Println(y == nil)	  	// true

z := *new([5]bool)		  	// var a [5]bool
fmt.Println(z == [5]bool{}) // true
```

`copy` 함수를 이용하면 하나의 슬라이스나 배열을 다른 슬라이스나 배열에 복사하고 복사된 요소의 개수를 반환한다

이 때 할당하는 요소(soucre slice)가 모두 복사되지 않고 할당받는 슬라이스(destination slice)의 길이만큼 복사된다

```go
type Ta []int
type Tb []int
dest := Ta{1, 2, 3}
src := Tb{4, 5, 6, 7, 8, 9}

n := copy(dest, src)
fmt.Println(n, dest) // 3 [4 5 6]

n = copy(dest[1:], dest)
fmt.Println(n, dest) // 2 [4 4 5]

a_dest := [4]int{}

n = copy(a_dest[:], src)
fmt.Println(n, a_dest) // 4 [4 5 6 7]

n = copy(a_dest[:], a_dest[2:])
fmt.Println(n, a_dest) // 2 [6 7 6 7]
```

### 컨테이너 요소에 대한 포인터

배열은 직접 값 부분(Direct Part)에 데이터를 모두 저장한다

따라서 해당 요소가 주소 지정 가능한 타입인 경우에만 포인터를 사용할 수 있다

슬라이스는 하부 값 부분(Underlying Part)에 요소를 저장하기 때문에 요소의 타입이 주소 지정 가능하지 않더라도 항상 포인터를 사용할 수 있다

맵의 요소는 항상 주소 지정이 불가능하다

```go
a := [5]int{1,2,3,4}
s := make([]bool, 2)

pa2, ps1 := &a[2], &s[1]
fmt.Println(*pa2, *ps1) // 3, false

a[2], s[1] = 100, true
fmt.Println(*pa2, *ps1) // 100, true

ps0 := &[]string{"Go", "C"}[0]
fmt.Println(*ps0) // Go

m := map[int]bool{1: true}
_ = m

// 배열은 맵, 슬라이스와 달리 직접 값 부분(Direct Part)에 데이터를 할당하므로 포인터 syntatic sugar를 사용할 수 없다
// _ = &[3]int{2,3,5}[0]

// 할당되지 않은 엔트리를 포인터로 사용할 수 없다
// _ = &map[int]bool{1: true}[1]

// 맵의 값을 포인터로 사용할 수 없다
// _ = &m[1]
```

맵 엔트리의 직접 값 부분은 전체 수정만 허용하기 때문에 엔트리의 부분 수정을 할 수 없다

따라서 맵의 값이 배열이나 구조체인 경우 배열 인덱싱이나 구조체 `.` 연산자를 통해 특정 필드를 수정할 수 없다

특정 부분만 수정하고 싶은 경우 해당 엔트리를 임시 변수로 꺼내서, 임시 변수를 통해 값을 수정하고 다시 덮어쓰면 된다

```go
type Book struct {price int}
mb := map[string]Book{}
mb["Go"] = Book{price: 100}
fmt.Println(mb) // map[Go:{100}]

ma := map[int][5]int{}
ma[1] = [5]int{1: 789}
fmt.Println(ma) // map[1:[0 789 0 0 0]]

// 컴파일 오류
// 맵 엔트리의 직접 값 부분(Direct Part)은 부분 수정을 할 수 없다
// 따라서 구조체나 배열의 특정 일부 값을 수정할 수 없다
// mb["Go"].price = 200
// ma[1][1] = 123

// 대신 전체 수정(덮어쓰기)는 허용한다
mb["Go"] = Book{price: 200}
ma[1] = [5]int{1: 123}
fmt.Println(mb) // map[Go:{200}]
fmt.Println(ma) // map[1:[0 123 0 0 0]]

// 덮어쓰기 메커니즘을 이용해서 엔트리를 임시 변수에 옮기고 
// 값을 수정한 뒤 다시 덮어쓰면 일부분만 수정하는 것과 같아진다
tmp := mb["Go"]
tmp.price = 300
mb["Go"] = tmp
fmt.Println(mb) // map[Go:{300}]
```

### 컨테이너 요소 이터레이션

컨테이너의 요소를 순회할 때는 `for range` 반복문을 사용한다

key, element는 이터레이션 변수라고 하며, 배열이나 슬라이스인 경우 int 타입의 인덱스가 key 값이 된다

변수 할당 키워드로 `=` `:=` 모두 사용할 수 있다

`_` 키워드를 사용하거나 이터레이션 변수명을 명시하지 않으면 이터레이션 변수 할당이 생략된다

```go
for key, element = range container {
    code
}
```

```go
// 맵의 이터레이션 순서는 보장되지 않는다
// 순회하는 도중 아직 순회하지 못한 엔트리가 삭제된 경우 순회하지 않는다
// 순회하는 도중 새로운 엔트리가 추가된 경우 순회하거나 하지 않을 수 있다
m := map[string]int{"C": 1972, "C++": 1983, "Go": 2009}
for lang, year := range m {
    fmt.Printf("%v: %v \n", lang, year)
}

a := [...]int{1, 2, 3, 4, 5}
for i, prime := range a {
    fmt.Printf("%v: %v \n", i, prime)
}

s := []string{"go", "defer", "goto", "var"}
for i, keyword := range s {
    fmt.Printf("%v: %v \n", i, keyword)
}
```

`container`은 원본 컨테이너의 값 부분(Direct Part)를 복사한 값이며, 이터레이션 변수 역시 복사된 컨테이너로부터 복사된 값이다 (배열의 크기가 클수록 비용 소모가 커진다)

따라서 `for range` 문에서 복사된 배열의 값을 할당받은 이터레이션 변수를 수정해도 원본 배열에 반영되지 않는다

슬라이스와 맵의 경우에도 마찬가지로 `for range` 문에서의 이터레이션 변수 조작은 원본 슬라이스와 맵의 요소에 반영되지 않는다

대신 `for range` 문에서 인덱싱이나 맵의 키로 직접 접근하여 값을 수정하면 원본 컨테이너의 요소와 이터레이션 변수에 반영이 된다 (예외: 배열 인덱싱을 통해 요소를 수정해도 배열 이터레이션 변수에는 적용되지 않는다)


## 채널

[채널](./동시성.md#채널)

## 메서드

Go에서 말하는 메서드 타입은 전통적인 객체지향 언어의 메서드와 사뭇 다르다

Go는 **리시버(Recevier)** 를 사용하여 함수를 특정 타입에 붙이는 개념을 메서드라고 한다

즉, **특정 타입에 연결된 함수** 가 **메서드** 이며 연결된 함수는 해당 타입의 값(또는 포인터)에 대해 작동할 수 있다

리시버는 메서드에 연결할 타입을 말하며 함수 선언 시, `func` 키워드 뒤에 위치한다

참고로 메서드는 같은 패키지에 존재하는 정의된 타입(defined type)에만 정의될 수 있다 -> 내장 함수에 대한 메서드를 정의할 수 없다

```go
/* 메서드 정의 구문
func (receiver argument) name(paramter types) return types {
    code
}
*/

type book {
    title string
}

// book 타입이 getTitle의 리시버가 된다 (값 리시버)
func (b book) getTitle() string {
    return b.title
}

func main() {
    // book 타입의 값 변수 b
    b := book{title: "golang"}

    // golang"
    b.getTitle()
}
```

아래와 같이 다른 타입(A)을 기반으로 하는 타입(B) 있을 때, A 타입을 리시버로 하는 메서드를 B 타입에서 호출할 수 없다

```go
type myInt int

func (m myInt) isOdd() bool {
    return m%2 ==1
}

type price myInt 

func main() {

    var x myInt = 3
    _ = x.isOdd()

    var p price = 1000
    // _ = p.isOdd()  // 컴파일 오류: p.isOdd() undefined
    _ = p
}
```

### 메서드 리시버

리시버는 두 가지 형태로 정의할 수 있다 (두 형태 모두 하나의 파라미터만 받을 수 있다)

**값 리시버 (Value Receiver)**: `func (t Type) methodName(...)`
- 메서드가 호출될 때 리시버 타입의 값의 복사본이 메서드에 전달된다
- 메서드 내에서 리시버의 복사본을 변경해도 원본 값에 영향을 미치지 않는다
- 값 타입(`int`, `string`, `struct`)에 대해 주로 사용된다

**포인터 리시버 (Pointer Recevier)**: `func (t *Type) methodName(...)`
- 메서드가 호출될 때 리시버 타입의 주소(포인터)가 메서드에 전달된다
- 메서드 내에서 포인터를 통해 리시버의 값을 변경하면 원본 값에 영향을 미친다
- 하부 값 부분(Underlying Part) 자체는 복사되지 않는다

일반적으로 **특정 타입에 대한 모든 메서드는 동일한 종류(모두 값 또는 모두 포인터)의 리시버를 사용** 하는 것이 관례이다

컴파일러가 메서드 호출 표현식에 대해 자동으로 변환을 진행하여 메서드 호출 시 문법상 변수와 리시버 타입이 일치하지 않아도 (`포인터 변수 - 값 리시버` 또는 `변수 - 포인터 리시버`) 호출할 수 있다

#### 값 리시버를 사용한 메서드

```go
// 구조체(타입) 정의
type circle struct {
	radius float64
}

// circle 타입에 연결된 메서드 선언
// 값 리시버 (c circle)
func (c circle) area() float64 {
	return 3.14 * c.radius * c.radius
}

func (c circle) describe() {
	fmt.Printf("원의 반지름: %.2f, 면적: %.2f\n", c.radius, c.area())
}

/*
    위 메서드에 대해 컴파일러는 아래와 같이 함수를 암시적으로 선언한다

    func circle.area(c circle) float64 {
	    return 3.14 * c.radius * c.radius
    }

    func circle.describe(c circle) {
	    fmt.Printf("원의 반지름: %.2f, 면적: %.2f\n", c.radius, c.area())
    }
*/
```

#### 포인터 리시버를 사용한 메서드

```go
type wallet struct {
	balance int
}

// wallet 타입에 연결된 메서드
// 포인터 리시버 (w *wallet)
func (w *wallet) deposit(amount int) {
	w.balance += amount
	fmt.Printf("%d원 입금, 현재 잔액: %d원\n", amount, w.balance)
}

/*
    위 메서드에 대해 컴파일러는 아래와 같이 함수를 암시적으로 선언한다

    func wallet.deposit(w *wallet, amount int) {
        w.balance += amount
        fmt.Printf("%d원 입금, 현재 잔액: %d원\n", amount, w.balance)
    }
*/
```

### 메서드 호출

선언된 메서드는 타입의 각 값에 멤버 함수로 취급된다

타입 `T`의 메서드 `m()`는 `T`의 변수 `v`를 통해 `v.m()`으로 호출될 수 있다

C 언어와 달리 Go에서는 포인터 리시버 메서드도 `v.m()`으로 호출하며 `(&v)->m()` 구문은 허용하지 않는다

#### 리시버 인자 복사

메서드의 리시버 타입이 값(`func (b Book) setTitle(title string)`)이라면 `b.setTitle("golang")` 메서드 호출 시 값 `b`는 복사되어 메서드로 전달된다

값 리시버 메서드에서 값을 변경해도 값 변수 `v`에는 영향을 주지 않는다

메서드의 리시버 타입이 포인터(`func (b *Book) setValue(title string)`)라면 `b.setTitle("golang")` 메서드 호출 시 값 `b`의 포인터가 복사되어 메서드로 전달된다

포인터 리시버 메서드는 값 리시버 메서드와 달리 주소를 공유하기 때문에 메서드 내의 변경 사항이 외부에도 영향을 끼치게 된다

#### 포인터 변수의 값인 `nil` 경우 메서드 호출

포인터 리시버 메서드 호출 시 리시버 타입의 변수 값이 `nil`인 경우에도 메서드는 정상적으로 호출될 수 있다

다만 **메서드 내부에서 `nil` 포인터를 역참조하여 필드에 접근하거나 메서드를 호출하는 시점에 런타임 패닉이 발생한다**

즉, 메서드 호출 행위 자체는 `nil`에 대해 유효하지만 `nil` 포인터가 가리키는 메모리에 접근할 때 문제가 발생한다

포인터 리시버 메서드에 `nil` 체크 로직을 추가하여 `nil` 포인터 역참조로 인한 런타임 패닉을 방지할 수 있다

```go
type book struct {
	title string
}

// nil 값 체크로 런타임 패닉 방지
func (b *book) setTitleNilCheck(title string) {
	if b != nil {
		b.title = title
	}
}

// nil 값 체크로 런타임 패닉 방지
func (b *book) getTitleNilCheck() string {
	if b != nil {
		return b.title
	}

	return ""
}

// nil 포인터 역참조로 인한 런타임 패닉 발생 가능
func (b *book) setTitle(title string) {
	b.title = title
}

// nil 포인터 역참조로 인한 런타임 패닉 발생 가능
func (b *book) getTitle() string {
	return b.title
}


func main() {

	var b *book

	// nil 포인터 역참조로 인한 런타임 패닉 발생
	// b.setTitle("golang")
	// b.getTitle()

	// nil 값 체크로 런타임 패닉 방지
	b.setTitleNilCheck("golang")
	b.getTitleNilCheck()
}
```

### 컴파일러의 메서드 값 정규화 (리시버 타입 자동 변환 규칙)

컴파일러는 메서드 호출의 일관성을 위해 컴파일 시점에 메서드 호출(메서드 값 표현식)을 내부적으로 정규화하는 작업을 수행한다

주로 **리시버의 형태(값 또는 포인터)** 와 **메서드의 리시버 타입(값 리시버 또는 포인터 리시버)** 간 불일치를 자동으로 해결한다

이를 리시버 타입 자동 변환 규칙이라고 하는데, 이 규칙이 발동하려면 메서드가 호출되는 변수(`T` 또는 `*T`)의 메서드셋에 호출하려는 메서드가 포함되어 있어야 한다 [메서드셋](#타입-셋과-메서드-셋)

컴파일러의 메서드 호출 정규화 시나리오
- 값 리시버 변수(`T`)에서 값 리시버 메서드(`(t T)`) 호출
    - `var v T; v.method`
    - 특별한 변환 없이 메서드가 `v`의 복사본을 인자로 받아 호출된다 (이미 정규화된 형태)
- 포인터 리시버 변수(`*T`)에서 포인터 리시버 메서드(`(t *T)`) 호출
    - `var p *T; p.method()`
    - 특별한 변환 없이 `p`의 값(포인터)이 인자로 전달되어 호출된다 (이미 정규화된 형태)
- 값 리시버 변수(`T`)에서 포인터 리시버 메서드(`(t *T)`) 호출
    - `var v T; v.method()`
    - 컴파일러는 `v.method()`를 `(&v).method()`로 자동 변환한다 (`v`의 주소를 포인터 리시버 메서드에 전달)
    - 메서드가 `v`의 원본 값을 변경할 수 있도록 허용한다 (v가 리터럴 값 `T{...}`인 경우 컴파일러는 임시 변수를 만들어 주소를 가져와 메서드를 호출한다)
- 포인터 리시버 변수(`*T`)에서 값 리시버 메서드(`(t T)`) 호출
    - `var p *T; p.method()`
    - 컴파일러는 `p.method()`를 `(*p).method()`로 자동 변환한다 (`p`가 가리키는 값을 역참조하여 그 값의 복사본을 값 리시버 메서드에 전달)
    - `p`가 `nil` 포인터라면 역참조 시점에서 런타임 패닉이 발생할 수 있다

### 정규화된 메서드 표현식의 평가 (런타임)

컴파일러가 메서드 호출을 정규화하여 올바른 형태 `receiver.method()` 호출로 변환하면, 이 표현식(메서드 호출)은 런타임에 평가된다

런타임 평가는 크게 두 가지로 나뉜다

#### 1. 일반 메서드 호출 (Call Expression)

`receiver.method()` 와 같은 직접적인 메서드 호출은 런타임에 다음과 같이 평가된다

1. 리시버 평가: 가장 먼저 리시버가 평가되어 실제 메서드가 호출될 대상(값 또는 포인터)이 결정된다
    - `v.method()` (값 리시버 `v`): `v`의 값이 평가된다
    - `(&v).method()` (포인터 리시버 `&v`): `v`의 주소가 평가된다
    - `p.method()` (포인터 리시버 `p`): `p`의 값이 평가된다
    - `(*p).method()` (값 리시버 `*p`): `p`가 가리키는 값이 평가된다 (`nil` 역참조 시 런타임 패닉 발생 가능)
2. 인자 평가: 메서드에 전달되는 인자(파라미터) 표현식이 평가된다
3. 메서드 실행: 평가된 리시버와 인자 값을 가지고 해당 메서드의 코드가 실행된다

#### 2. 메서드 값 평가 (Method Value)

메서드 호출 없이 메서드 자체를 변수에 할당하거나 다른 함수에 인자로 전달하는 것을 **메서드 값 (Method Value)** 라고 한다

메서드 값은 특정 리시버에 바인딩된 함수 클로저와 같다 -> 메서드 값을 할당받은 변수는 해당 리시버의 원래 정보를 캡처한다

`f := v.method` (값 리시버 메서드 값 할당)

`f := p.method` (포인터 리시버 메서드 값 할당)

메서드 값이 정의되는 선언 시점에 리시버 `v`나 `p`의 현재 값이 메서드 클로저에 **캡처** 된다 (메서드 값이 생성될 때 리시버가 평가된다)

이후 `f()`처럼 할당된 메서드 값을 호출할 때는 이미 캡처된 리시버를 사용하여 메서드가 실행되는데, 이 때 리시버 변수를 더 이상 평가하지 않는다

값 리시버 변수(`T`)로부터 메서드 값을 생성하는 경우
- `var v; f := v.method`
- 런타임 평가: `f`가 할당되는 순간 `v`의 복사본이 `f` 클로저에 캡처된다. 이후 `v`의 값이 변경되어도 `f`가 사용하는 리시버는 캡처된 복사본이므로 영향을 받지 않는다

포인터 리시버 변수(`*T`)로부터 메서드 값을 생성하는 경우
- `var p *T; f := p.method`
- 런타임 평가: `f`가 할당되는 순간 `p`의 **포인터(현재 주소 값)** 가 `f` 클로저에 캡처된다. 이후 `p`가 가리키는 원본 데이터(`*p`)의 값이 변경되면 `f`는 캡처된 포인터를 통해 그 변경된 데이터를 참조하게 된다
- `f`를 호출할 때 `p` 자체가 `nil`이었다면 `f`내부에서 `nil` 포인터 역참조가 발생할 수 있다

```go
type counter struct {
	value int
}

// 포인터 리시버 메서드
func (c *counter) increment() {
	c.value++
}

// 값 리시버 메서드
func (c counter) getValue() int {
	return c.value
}


func main() {

	// 포인터 변수
	cnt := 	&counter{value: 0} 

	// 메서드 값 생성 (cnt 주소가 cntIncrement 클로저에 캡처된다)
	cntIncrement := cnt.increment 

	cntIncrement()
	cntIncrement()
	cntIncrement()

	// 원본 데이터가 변경되었다
	fmt.Println(cnt.getValue())

	// cnt의 포인터를 변경한다
	cnt = &counter{value: 100}

	cntIncrement()
	cntIncrement()
	cntIncrement()

	// cnt는 새로운 포인터를 가리키므로 변경에 영향을 받지 않는다
	fmt.Println(cnt.getValue())


	// 값 변수
	valCnt := counter{value: 0}

	// 메서드 값 생성 (valCnt의 값이 복사된 후 valCntIncrment 클로저에 캡처된다)
	valGetValue := valCnt.getValue

	// 원본 값을 변경한다
	valCnt.increment()
	valCnt.increment()
	valCnt.increment()

	// 메서드 값에 캡처된 복사본은 영향을 받지 않는다
	fmt.Println(valGetValue())
}
```






### 메서드 명세와 메서드 셋

메서드 명세(Method Specification)는 메서드의 시그니처를 의미하며 주로 인터페이스 타입을 정의할 때 사용된다

인터페이스는 특정 메서드 명세들의 집합을 정의하며 어떤 타입이든 해당 인터페이스의 모든 메서드 명세를 구현하면 그 인터페이스를 만족한다고 간주된다

**메서드 시그니처**: 메서드 이름, 매개변수 타입, 반환 값 타입 (리시버는 메서드 명세의 일부가 아니다)

```go
// area 메서드 명세: 이름 area, 매개변수 없음, float64 반환
func (c circle) area() float64

// setName 메서드 명세: 이름 setName, 매개변수 string, 반환값 없음
func (b *book) setName(name string)
```

메서드 집합은 특정 타입이 호출할 수 있는 모든 메서드들의 집합을 의미한다

Go 컴파일러는 각 타입에 대해 메서드 집합을 결정하는데, 해당 타입의 메서드 집합을 기반으로 하여 어떤 인터페이스를 만족하는지 판단한다

메서드 집합은 리시버 타입에 따라 다르게 결정된다

**값 타입(`T`)의 메서드 집합**
- 값 리시버(`(t T)`)를 가진 `T`의 모든 메서드: `T` 타입에 값 리시버로 정의된 모든 메서드
- 포인터 리시버(`(t *T)`)를 가진 `T`의 모든 메서드: `T` 타입에 포인터 리시버로 정의된 모든 메서드

Go는 `T` 타입의 변수 `v`가 있을 때 `v.method()`가 포인트 리시버 메서드이더라도 컴파일러가 자동으로 `(&v).method()`로 변환하여 호출할 수 있도록 해준다

이로 인해 값 타입의 메서드 집합에는 해당 타입의 포인터 리시버 메서드도 포함된다

**포인터 타입(`*T`)의 메서드 집합** 도 마찬가지로 컴파일러가 자동으로 역참조하여 호출하므로 포인터 타입의 메서드 집합에도 해당 타입의 값 리시버 메서드가 포함된다

```go
// 구조체(타입) 정의
// MyStruct 타입의 메서드 집합: {getValue, setValue}
type MyStruct struct {
	value int
}


// 값 리시버 메서드
func (s MyStruct) getValue() int {
	return s.value
}

// 포인터 리시버 메서드
func (s *MyStruct) setValue(value int) {
	s.value = value
}


func main() {

	// 값 타입 변수
	// s1 (MyStruct 타입)은 getValue(), setValue() 모두 호출할 수 있다
	var s1 MyStruct 

	// getValue()는 값 리시버 메서드이므로 변환하지 않고 호출한다
	fmt.Println(s1.getValue()) 

	// setValue()는 포인터 리시버 메서드지만 컴파일러가 (&s1).setValue(10)으로 변환 후 호출한다
	s1.setValue(10)			   
	fmt.Println(s1.getValue()) 


	// 포인터 타입 변수
	// s2 (MyStruct 타입)은 getValue(), setValue() 모두 호출할 수 있다
	s2 := &MyStruct{} 

	// getValue()는 값 리시버 메서드지만 컴파일러가 (*s2).getValue()로 변환 후 호출한다 
	fmt.Println(s2.getValue())

	// setValue()는 포인터 리시버 메서드이므로 변환하지 않고 호출한다
	s2.setValue(20)
	fmt.Println(s2.getValue())
}
```

#### 인터페이스와 메서드 집합의 관계

인터페이스는 특정 메서드 명세의 집합이다

어떤 **구체 타입(Concrete Type)** 이 특정 인터페이스를 구현하려면 해당 구체 타입의 메서드 집합이 인터페이스에 정의된 모든 메서드 명세를 포함해야 한다

값 타입 `T`가 인터페이스 `I`를 만족하는 조건: `T`의 메서드 집합이 `I`의 모든 메서드 명세를 포함해야 한다

포인터 타입 `*T`가 인터페이스 `I`를 만족하는 조건: `*T`의 메서드 집합이 `I`의 모든 메서드 명세를 포함해야 한다


## 인터페이스

Go의 인터페이스는 자바의 객체지향적인 관점과는 완전히 다른 메커니즘을 가진다

자바 인터페이스는 특정 기능을 구현할 것이라는 것을 선언하는 일종의 계약서다

클래스가 `implements` 키워드를 사용하여 인터페이스를 구현한다고 선언하면 인터페이스와 상하 관계를 가지고 모든 기능을 구현해야 한다

반면 Go의 인터페이스는 어떤 타입이든 인터페이스에 정의된 모든 메서드를 가지고 있다면, 그 타입은 해당 인터페이스를 만족한다고 간주된다

자바와 달리 명시적인 `implements` 키워드가 없으며 강제적인 기능 구현을 유도하지 않는다

Go 인터페이스의 핵심은 **덕 타이핑(Duck Typing)** 이다

"만약 어떤 것이 오리처럼 걷고, 오리처럼 꽥꽥거린다면 그것은 오리이다" 라는 비유는 Go에서 "만약 어떤 타입이 특정 인터페이스가 요구하는 메서드들을 가지고 있다면, 그 타입은 그 인터페이스의 타입이다" 라는 의미로 해석된다

**특정 타입이 인터페이스를 만족하는지의 여부는 대부분 컴파일 시점에 타입 검사가 완료된다**

```go
/*
	=======
	타입 정의
	=======
*/

// 인터페이스 정의, speak() 메서드를 가진 모든 타입은 Speaker를 만족한다
type speaker interface {
	speak() string
}

type person struct {
	name string
}

type dog struct {
	breed string
}

/*
	========
	메서드 정의
	========
*/

// person 타입의  speak 메서드
func (p person) speak() string {
	return "hello " + p.name
}

// dog 타입의  speak 메서드
func (d dog) speak() string {
	return "woof " + d.breed
}

// 다형성을 활용하는 함수
func say(s speaker) {
	fmt.Println(s.speak())
}

func main() {

	p := person{name: "hansanhha"}
	d := dog{breed: "golden retriever"}

	say(p)
	say(d)

	// 인터페이스 변수에 직접 할당할 수도 있다
	var speaker1 speaker = p
	var speaker2 speaker = d

	fmt.Println(speaker1.speak())
	fmt.Println(speaker2.speak())
}
```

Go에서 인터페이스 그 자체로 타입이 되므로, 인터페이스 타입의 변수는 해당 인터페이스를 만족하는 어떤 타입의 값이라도 담을 수 있다 (자바의 익명 클래스 느낌)

```go
var s speaker

s = person{name: "hansanhha"}  // person은 speaker를 만족하므로 할당 가능
s = dog{breed: "poodle"} // dog도 spearker를 만족하므로 할당 가능
```

### 다형성: 동적 타입과 동적 값

Go의 인터페이스는 특정 타입과 실제로 연결되어 있지 않기 때문에 컴파일 시점에는 인터페이스 타입만 알고, 런타임에 인터페이스 변수 내부에 어떤 구체적인 타입의 값이 들어있는지를 모른다

아래와 같이 명시적으로 변수의 타입을 인터페이스 타입으로 선언을 해야 컴파일 시점에 인터페이스 타입인 것을 알 수 있다

```go
type speaker interface {
    speak()
}

var s speaker; // 인터페이스 타입의 변수 선언
```

자바처럼 객체 간의 관계를 직접적으로 연결하지 않음에도 불구하고 Go에서 다형성을 이용할 수 있는 이유는 **동적 타입** 과 **동적 값** 덕분이다

동적 타입 또는 동적 타입 포인터는 변수에 할당되어 있는 **구체적인 타입(Concrete Type)** 의 정보를 가리킨다

동적 값 또는 동적 값 포인터는 변수에 할당되어 있는 **실제 데이터(값)** 를 가리킨다

Go 런타임은 인터페이스를 만족한 구현체 중 해당 변수에 할당된 구체 타입의 메서드를 실행시키기 위해 동적 타입 포인터를 사용한다

동적 타입 포인터를 통해 구체 타입의 메서드 테이블을 찾아가고, 메서드 테이블에서 호출하려는 메서드 이름에 해당 하는 실제 함수 포인터를 찾는다

그리고 값 포인터를 사용해 구체 타입의 데이터(인스턴스)를 메서드의 리시버로 전달하여 해당 함수를 호출한다

### 메서드가 포인터 리시버인 경우 값 타입과 리시버의 타입이 일치해야 한다

자바에서는 객체의 메서드를 호출할 때 항상 내부적으로 참조(포인터)를 통해 접근하므로 Go만큼 명시적으로 드러나지 않는다

Go에서는 메서드 호출 시 정의된 리시버의 값과 포인터에 따라 메서드 동작이 달라지게 된다

값 리시버 메서드는 값의 복사본을 전달하고, 포인터 리시버 메서드는 값의 주소를 전달한다 -> 값 리시버는 메서드 내에서 원본을 변경할 수 없고 포인터 리시버는 변경할 수 있다

따라서 Go에서는 메서드의 리시버를 값으로 받을지(`t T`), 포인터로 받을지(`(t *T)`)가 매우 중요한 선택이며, 이는 해당 타입이 어떤 인터페이스를 만족하는지에도 직접적인 영향을 끼친다

**컴파일러는 메서드가 포인터 리시버인 경우 값 타입과 리시버의 타입이 일치해야 인터페이스를 만족한다고 판단한다**

만약 메서드를 포인터 리시버 메서드로 선언한 경우, 변수가 값 타입이라면 포인터 타입이 아니므로 인터페이스를 만족하지 못한 것으로 판단하여 컴파일 오류가 발생한다

값 타입의 변수의 주소를 인터페이스 변수에 할당하면 이러한 문제를 해결할 수 있다

```go
type writer interface {
	write() string
}

type filmWriter struct {
	title string
}

// writer 인터페이스의 메서드를 포인터 리시버 메서드로 구현한다
func (f *filmWriter) write() string {
	return f.title
}

func main() {

	/*
		아래의 코드는 모두 컴파일 오류가 발생한다
		
		컴파일러는 구체 타입의 메서드 시그니처와 리시버 타입을 정확히 일치시켜야만 인터페이스를 만족한다고 판단한다

		fileWriter의 write() 메서드는 값 타입이 아닌 포인터 리시버 메서드이므로 포인터 타입(*filmWriter)만이 writer 인터페이스의 writer()를 구현한 것으로 간주한다

		var w writer

		writer = filmWriter{title: "the shawshank redemption"}
	
		fw := filmWriter{title: "the shawshank redemption"}
		w = fw	
	*/

	var w writer

	// 값 타입으로 선언하고 주소를 넘겨주면 컴파일 오류를 해결할 수 있다
	fw := filmWriter{title: "the shawshank redemption"}
	w = &fw
	fmt.Println(w.write())

	w = &filmWriter{title: "inception"}
	fmt.Println(w.write())
}
```

### 타입 셋과 메서드 셋

**타입 셋** 은 특정 인터페이스가 만족시킬 수 있는 구체적인 타입들의 집합을 의미한다 (인터페이스가 무엇을 표현할 수 있는가에 대한 정의)

컴파일러가 인터페이스의 메서드 셋을 기반으로 내부적으로 추론하고 관리하는데 사용하는 개념이다

컴파일러 관점에서 인터페이스 `I`가 있을 때 `I`의 타입 셋은 `I`가 요구하는 모든 메서드를 가진 모든 타입들의 모임이다

Go는 덕 타이핑으로 인터페이스를 만족시키기 때문에 어떤 타입이든 인터페이스의 요구사항을 충족하면 그 인터페이스의 타입 셋에 포함된다

```go
// Mover 인터페이스의 타입 셋에는 Bird, Car, Airplane이 포함된다
// 이들은 모두 Move() 메서드를 가진다
type Mover interface {
    Move()
}

type Bird struct {}
func (b Bird) Move() {}

type Car struct {}
func (c Car) Move() {}

type Airplane struct {}
func (a Airplane) Move() {}
```

**메서드 셋** 은 특정 타입이 가지고 있는 모든 메서드들의 집합을 말한다 (특정 구체 타입이 무엇을 할 수 있는지에 대한 정의)

컴파일러는 메서드 셋을 기준으로 인터페이스 만족 여부를 판단한다

값 타입 `T`의 메서드 셋은 `T`를 리시버로 가지는 모든 메서드만을 포함한다

포인터 타입 `*T`의 메서드 셋은 `T`를 리시버로 가지는 모든 메서드와 `*T`를 리시버로 가지는 모든 메서드를 포함한다

어떤 구체 타입 `T`가 인터페이스 `I`를 만족하려면 `T`의 인스턴스(포인터 또는 값 타입)인 `C`의 메서드 셋이 `I`의 메서드 셋을 포함해야 한다

```go
type Speaker interface {
    Speak() string  // Speaker 인터페이스의 메서드 셋: {Speack()}
}

type Animal struct {
    Name string
}

// 1. 값 리시버 메서드
func (a Animal) SayHello() string {
    return "hello " + a.Name
}

// 2. 포인터 리시버 메서드
func (a *Animal) SetName(newName string) {
    a.Name = newName
}

// 3. 인터페이스 Speaker의 메서드와 동일한 시그니처 (값 리시버)
func (a Animal) Speak() string {
    return a.Name + " speaks"
}

func main() {

    // Animal (값 타입)의 메서드 셋: {SayHello() string, Speak() string}
    var lion Animal = Animal{Name: "Lion"}

    fmt.Println(lion.SayHello())
    fmt.Println(lion.Speak())
    // lion의 메서드 셋에 포함되지 않지만 자동 변환 규칙에 의해 (&lion).SetName("New Lion")으로 호출된다
    // SetName은 인터페이스의 메서드가 아니므로 자동 변환 규칙이 적용된다
    lion.SetName("New Lion")

    // lion은 Speaker 인터페이스를 만족한다
    var s Speaker = lion
    fmt.Println(s.Speak())


    // Animal (포인터 타입)의 메서드 셋: {SayHello() string, SetName(string), Speak() string}
    var tiger *Animal = &Animal{Name: "Tiger"}

    fmt.Println(tiger.SayHello())
    fmt.Println(tiger.Speak())
    tiger.SetName("New Tiger")

	// 포인터 타입은 값 타입의 메서드셋도 포함하므로 인터페이스를 만족한다
    s = tiger
	fmt.Println(s.Speak())
}
```

### 값 박싱

Go에서 인터페이스의 값 박싱은 구체적인 값을 인터페이스 타입으로 변환할 때 일어나는 내부적인 메모리 처리 과정을 말한다

구체적인 타입의 값을 인터페이스 타입의 변수에 할당할 때 해당 구체적인 값의 사본이 인터페이스 변수의 메모리 영역으로 복사되거나, 값의 주소와 타입 정보가 인터페이스 변수에 저장된다

[단일 값 부분](#단일-값-부분-타입-solo-direct-value-part)인 경우 직접 값이 복사되고, [다중 값 부분](#다중-값-부분-타입-direct-value-part---underlying-indirect-value-part-n개)이라면 헤드만 복사된다

값 박싱이 발생하는 경우는 다음과 같다

#### 1. 구체적인 값을 인터페이스 변수에 할당할 때

```go
// Speaker는 인터페이스, Person은 구체 타입이다
var s Speaker
p := Person{Name: "hansanhha"}

// p의 값이 s 인터페이스 변수 내부로 복사된다
// s의 동적 타입은 Person, 동적 값은 {Name: "hansanhha"}의 복사본이 된다
s = p
```

#### 2. 구체적인 타입을 반환하는 함수가 인터페이스 타입을 반환하도록 명시할 때

```go
func GetSpeaker() Speaker {
    // Person 값이 Speaker 인터페이스 타입으로 박싱되어 반환된다
    return Person{Name: "hansanhha"} 
}
```

#### 3. 구체적인 타입을 인자로 받는 함수가 인터페이스 타입 매개변수를 가질 때

```go
func process(s Speaker) {
    ...
} 

// Person 값이 Speaker 인터페이스 타입으로 박싱되어 전달된다
process(Person{Name: "hansanhha"})
```

### `type-switch` 문

[`type-switch` 문](./문법.md#type-switch-문)

### `interface{}`와 `any`

`interface{}`는 아무런 메서드도 가지지 않은 인터페이스를 의미한다

Go는 특정 타입의 메서드 셋이 인터페이스의 메서드 셋을 포함하는 경우 인터페이스를 만족한다고 판단한다

인터페이스에 아무런 메서드가 정의되어 있지 않으면 모든 타입이 해당 인터페이스를 만족한다고 판단할 수 있다

따라서 **`interface {}`는 모든 타입의 값을 담을 수 있다** (자바의 `Object` 느낌)

Go는 정적 타입 언어이므로 컴파일에 특정 타입으로 결정되어야 하므로 일반적으로 변수는 하나의 타입만 담을 수 있다

`interface{}` 타입의 변수는 모든 타입의 값을 담을 수 있으므로 하나의 변수가 여러 타입의 값을 담을 수 있게 된다

구체적인 값은 `interface{}` 변수에 할당할 때, 해당 값은 인터페이스 변수 내부로 박싱된다 (동적 타입, 동적 값 형태)

어떤 타입이든 담을 수 있지만 `interface{}` 변수에 담긴 값은 컴파일 시점에 그 구체적인 타입을 알 수 없다

그 값의 원래 타입에 정의된 필드나 메서드에 직접 접근할 수 없게 된다

`interface` 변수에 담긴 구체적인 값을 사용하려면 타입 어설션이나 타입 스위치를 사용하여 런타임에 그 타입을 확인하고 원래 타입으로 변환해야 한다 (자바의 `instanceof` 느낌)

```go
var i interface{}

// int 타입 값 할당
i = 10
fmt.Printf("%v, %T\n", i, i)

// string 타입 값 할당
i = "hello go"
fmt.Printf("%v, %T\n", i, i)

type Book struct {
    title string
    price int
}

b := Book{title: "golang", price: 10_000}
i = b
fmt.Printf("%v, %T\n", i, i)
// `interface{}` 타입의 변수로 구조체의 필드에 접근할 수 없다
// _  = i.title
// _ = i.price

i = []int{1, 2, 3}
fmt.Printf("%v, %T\n", i, i)

// `interface{}` 타입의 변수로 슬라이스 인덱싱을 할 수 없다
// _ = i[0]
// _ = i[1]
// _ = i[2]

// 타입 어설션(런타임 타입 확인)을 통해 구체적인 타입을 통해 값에 접근할 수 있다
if val, ok := i.([]int); ok {
    fmt.Println(val[0])
    fmt.Println(val[1])
    fmt.Println(val[2])
}
```

**`any`**는 Go 1.18 버전에 도입된 `interface{}` 타입의 별칭으로 두 타입은 컴파일러에 의해 동일하게 처리된다

런타임 동작이나 성능에는 차이가 없으나 코드의 가독성을 높여준다


베이직 인터페이스, 리플렉션


## 타입 임베딩

타입 임베딩은 구조체 내부에 이름없이 다른 구조체 또는 인터페이스를 선언하는 것을 말한다

임베딩한 구조체는 임베딩된 타입의 필드와 메서드에 직접 접근할 수 있게 된다

Go는 자바의 클래스 기반 상속을 직접 제공하지 않지만 타입 임베딩 기능을 통해 **합성(Composition)** 을 기반으로 하는 코드 재사용 메커니즘을 제공한다

다른 구조체나 인터페이스를 포함하여 자신의 필드나 메서드처럼 사용한다고 해도 **승격(Promotion)** 이라는 표현을 사용한다

### 구조체 임베딩

자바의 경우 부모 클래스 타입의 변수에 자식 클래스 인스턴스를 할당하여 다형성을 활용할 수 있다

```java
Person p = new Employee();
p.greet();
```

Go에서는 구조체 간의 상하 관계가 없으므로 임베딩에서 자바처럼 자동적인 다형적 할당을 이용할 수 없다

또한 바깥 구조체의 메서드 이름과 임베딩한 구조체의 메서드 이름이 동일한 경우 바깥 구조체의 메서드가 우선된다

이를 섀도잉 또는 프로모션된 메서드 오버라이딩이라고 하며, 바깥 구조체가 아닌 임베딩한 구조체의 메서드에 접근하려면 명시적인 접근이 필요하다

아래 코드처럼 `Employee` 구조체를 `Person` 타입 변수에 직접 할당하면 컴파일 오류가 발생한다 (Go의 다형성은 주로 인터페이스를 통해 구현된다)

`var p Person = Employee {...}`


```go
// person 구조체 정의
type person struct {
	name string
}

// person 메서드
func (p person) greet() string {
	return fmt.Sprintf("hello %s", p.name)
}

// employee 구조체는 person 구조체를 임베딩한다
type employee struct {
	person
	id string
	role string
}

// employee 구조체도 person과 동일한 이름의 메서드를 정의한다
// 바깥 구조체와 임베딩한 구조체의 메서드 이름이 동일하면 바깥 구조체의 메서드가 우선된다
// 섀도잉(shadowing) 또는 프로모션된 메서드 오버라이딩이라고 한다
// 자바의 오버라이딩처럼 다형적 호출(super.method())이 발생하지 않는다
func (e employee) greet() string {
	return fmt.Sprintf("hello %s (%s %s)", e.name, e.id, e.role)
}

func struct_embedding() {
	e := employee {
		person: person{
			name: "hansanhha",
		},
		id: "1324",
		role: "coder",
	}

	// person의 필드를 마치 Employee의 필드인 것처럼 사용할 수 있다
	fmt.Println(e.name)

	// 임베딩한 타입을 통해서 접근할 수도 있다
	fmt.Println(e.person.name)
	
	// employee의 greet() 메서드가 person의 greet() 메서드보다 우선이다 (섀도잉)
	fmt.Println(e.greet())

	// 명시적으로 접근하면 임베딩한 타입의 메서드를 사용할 수 있다
	fmt.Println(e.person.greet())
}
```

### 인터페이스 임베딩

구조체에 여러 인터페이스를 임베딩하여 여러 인터페이스의 메서드 셋을 하나의 새로운 인터페이스로 합칠 수 있다

인터페이스 임베딩은 기존의 작고 독립적인 인터페이스들을 조합하여 더 크고 기능적인 인터페이스를 만들 때 유용하다

```go
// ReadWriter 인터페이스는 io.Reader와 io.Writer 인터페이스를 임베딩한다
type ReadWriter interface {
	io.Reader // Read(p []byte) (n int, err error) 메서드 포함
	io.Writer // Write(p []byte) (n int, err error) 메서드 포함
	Close() error
}

// ReaderWriter 인터페이스를 만족하는 구현체
type MyFile struct {}

func (mf MyFile) Read(p []byte) (n int, err error) {
	fmt.Println("파일 열기")
	return len(p), nil
}

func (mf MyFile) Write(p []byte) (n int, err error) {
	fmt.Println("파일 쓰기")
	return len(p), nil
}

func (mf MyFile) Close() error {
	fmt.Println("파일 닫기")
	return nil
}

func interface_embedding() {

	// MyFile은 ReadWriter 인터페이스를 만족한다
	var rw ReadWriter = MyFile{}

	// ReaderWriter 메서드 호출
	rw.Read(make([]byte, 10))
	rw.Write([]byte("hello hansanhha"))
	rw.Close()

	// ReadWriter 타입은 io.Reader 타입으로도 사용할 수 있다
	var r io.Reader = rw
	r.Read(make([]byte, 5))
}
```


## 런타임 타입 검사: 타입 어설션, 타입 스위치

런타임 타입 검사는 컴파일 시점에는 알 수 없는 인터페이스 변수 내부의 구체적인 동적 타입을 프로그램이 실행되는 도중에 확인하는 기법을 말한다

주로 타입 어설션(Type Assertion)과 타입 스위치(Type Switch)를 통해 런타임에 타입 검사를 할 수 있다

### 타입 어설션

**타입 어설션** 은 인터페이스 변수에 담긴 값이 특정 구체 타입이거나 또는 특정 다른 인터페이스를 만족하는지 확인하고 변환하는 방법이다 (자바의 `instanceof` 느낌)

인터페이스 변수를 통해 접근하면 인터페이스의 메서드 셋에만 접근할 수 있는데 타입 어설션을 통해 구체 타입의 모든 필드와 메서드에 접근할 수 있게 된다

또는 주어진 인터페이스 변수가 다른 인터페이스도 만족하는지 확인할 수 있다

```go
concreteValue, ok := interfaceValue.(ConcreteType)
```

`concreteValue`: 주어진 구체 타입이라면 해당 타입으로 형변환된 값이 담긴다

`ok`: `interfaceValue`의 동적 타입이 `ConcreteType`과 일치하면 `true`, 아니면 `false`가 반환된다

`.(ConcreteType)`: `interfaceValue`가 `ConcreteType`인지 확인한 뒤, 맞다면 해당 타입으로 변환한다

### 타입 스위치

타입 스위치는 인터페이스의 변수의 동적 타입(구체 타입)이 여러 개 타입 중 어떤 것인지 판단하고  그에 따른 코드 블록을 실행한다

[`type-switch` 문 ](./문법.md#type-switch-문)